{"version":3,"sources":["../src/audit/chain.ts","../src/audit/logger.ts","../src/policy/types.ts","../src/policy/evaluator.ts","../src/policy/limits.ts","../src/policy/engine.ts","../src/keystore/secure-buffer.ts","../src/keystore/errors.ts","../src/keystore/local.ts","../src/keystore/index.ts","../src/xrpl/config.ts","../src/xrpl/client.ts","../src/signing/service.ts","../src/signing/multisig.ts","../src/tools/wallet-create.ts","../src/tools/wallet-sign.ts","../src/tools/wallet-balance.ts","../src/tools/wallet-policy-check.ts","../src/tools/wallet-rotate.ts","../src/tools/wallet-list.ts","../src/tools/wallet-history.ts","../src/tools/wallet-fund.ts","../src/tools/policy-set.ts","../src/tools/tx-submit.ts","../src/tools/tx-decode.ts","../src/server.ts"],"names":["crypto","path","z","stat","dropsToXrp","resolve","fs","DEFAULT_PASSWORD_POLICY","ARGON2_CONFIG","AES_CONFIG","hash","Wallet","decode"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Hash Chain Implementation for Audit Logging\n *\n * Implements HMAC-SHA256 hash chain for tamper-evident audit logs.\n * Formula: hash(N) = HMAC-SHA256(data_N || prev_hash)\n *\n * @module audit/chain\n * @version 1.0.0\n * @since 2026-01-28\n */\n\nimport { createHmac } from 'crypto';\nimport { z } from 'zod';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n/**\n * Genesis constant used to compute the starting hash of a new chain\n */\nconst GENESIS_CONSTANT = 'XRPL-WALLET-MCP-GENESIS-V1';\n\n/**\n * HMAC algorithm used for hash chain\n */\nconst HMAC_ALGORITHM = 'sha256';\n\n/**\n * Required HMAC key length in bytes (256 bits)\n */\nconst HMAC_KEY_LENGTH = 32;\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Current state of the hash chain\n */\nexport interface ChainState {\n  /** Current sequence number (0 if no entries) */\n  sequence: number;\n\n  /** Hash of the previous entry (or genesis hash if sequence is 0) */\n  previousHash: string;\n}\n\n/**\n * Error types that can occur during chain verification\n */\nexport type ChainErrorType =\n  | 'sequence_gap'\n  | 'chain_break'\n  | 'tampered_entry'\n  | 'invalid_timestamp';\n\n/**\n * Represents an error found during chain verification\n */\nexport interface ChainError {\n  /** Type of error detected */\n  type: ChainErrorType;\n\n  /** Sequence number where error was detected */\n  sequence: number;\n\n  /** Expected value */\n  expected: string | number;\n\n  /** Actual value found */\n  actual: string | number;\n\n  /** Human-readable description */\n  description: string;\n}\n\n/**\n * Result of chain verification\n */\nexport interface ChainVerificationResult {\n  /** Whether the chain is valid */\n  valid: boolean;\n\n  /** Number of entries verified */\n  entriesVerified: number;\n\n  /** First sequence number verified */\n  startSequence: number;\n\n  /** Last sequence number verified */\n  endSequence: number;\n\n  /** Verification duration in milliseconds */\n  durationMs: number;\n\n  /** List of detected errors */\n  errors: ChainError[];\n}\n\n/**\n * Options for chain verification\n */\nexport interface VerificationOptions {\n  /** Verify entire chain from genesis */\n  fullChain?: boolean;\n\n  /** Start sequence for range verification */\n  startSequence?: number;\n\n  /** End sequence for range verification */\n  endSequence?: number;\n\n  /** Number of recent entries to verify (default: 1000) */\n  recentEntries?: number;\n\n  /** Continue verification after finding errors */\n  continueOnError?: boolean;\n}\n\n/**\n * Data structure that can be hashed (must be JSON serializable)\n */\nexport interface HashableEntry {\n  /** Sequence number */\n  sequence: number;\n\n  /** Entry timestamp */\n  timestamp: string;\n\n  /** Hash of previous entry */\n  previousHash: string;\n\n  /** This entry's hash (excluded from hash computation) */\n  hash: string;\n\n  /** Any additional data */\n  [key: string]: unknown;\n}\n\n// ============================================================================\n// SCHEMAS\n// ============================================================================\n\n/**\n * Schema for HMAC key validation\n */\nexport const HmacKeySchema = z\n  .instanceof(Buffer)\n  .refine(\n    (buf) => buf.length === HMAC_KEY_LENGTH,\n    `HMAC key must be exactly ${HMAC_KEY_LENGTH} bytes (${HMAC_KEY_LENGTH * 8} bits)`\n  );\n\n/**\n * Schema for chain state\n */\nexport const ChainStateSchema = z.object({\n  sequence: z.number().int().min(0),\n  previousHash: z.string().length(64).regex(/^[a-f0-9]{64}$/i),\n});\n\n/**\n * Schema for verification options\n */\nexport const VerificationOptionsSchema = z.object({\n  fullChain: z.boolean().optional(),\n  startSequence: z.number().int().positive().optional(),\n  endSequence: z.number().int().positive().optional(),\n  recentEntries: z.number().int().positive().optional(),\n  continueOnError: z.boolean().optional(),\n});\n\n// ============================================================================\n// HASH CHAIN CLASS\n// ============================================================================\n\n/**\n * HashChain - Manages HMAC-SHA256 hash chain for tamper-evident logging\n *\n * The hash chain provides:\n * - Tamper detection: Any modification breaks the chain\n * - Deletion detection: Sequence gaps reveal deleted entries\n * - Cryptographic proof: HMAC-SHA256 provides strong integrity guarantee\n *\n * @example\n * ```typescript\n * const hmacKey = crypto.randomBytes(32);\n * const chain = new HashChain(hmacKey);\n *\n * const entry = chain.createEntry({ event: 'test', data: 'value' });\n * console.log(entry.hash); // HMAC-SHA256 hash\n *\n * // Later, verify entries\n * const result = chain.verifyEntries(entries);\n * if (!result.valid) {\n *   console.error('Chain tampering detected!', result.errors);\n * }\n * ```\n */\nexport class HashChain {\n  private readonly hmacKey: Buffer;\n  private state: ChainState;\n\n  /**\n   * Create a new HashChain instance\n   *\n   * @param hmacKey - 256-bit HMAC key (32 bytes)\n   * @param initialState - Optional initial chain state (for resuming)\n   * @throws Error if HMAC key is invalid\n   */\n  constructor(hmacKey: Buffer, initialState?: ChainState) {\n    // Validate HMAC key\n    const keyResult = HmacKeySchema.safeParse(hmacKey);\n    if (!keyResult.success) {\n      throw new Error(`Invalid HMAC key: ${keyResult.error.message}`);\n    }\n\n    this.hmacKey = Buffer.from(hmacKey); // Create defensive copy\n    this.state = initialState ?? {\n      sequence: 0,\n      previousHash: this.computeGenesisHash(),\n    };\n  }\n\n  /**\n   * Compute the genesis hash for a new chain\n   *\n   * The genesis hash is a well-known constant computed from the\n   * GENESIS_CONSTANT using the HMAC key. This provides a verifiable\n   * starting point for the chain.\n   *\n   * @returns Hex-encoded genesis hash\n   */\n  computeGenesisHash(): string {\n    const hmac = createHmac(HMAC_ALGORITHM, this.hmacKey);\n    hmac.update(GENESIS_CONSTANT);\n    return hmac.digest('hex');\n  }\n\n  /**\n   * Compute HMAC-SHA256 hash of entry data\n   *\n   * The hash includes all fields except 'hash' itself. Fields are\n   * sorted alphabetically for deterministic serialization.\n   *\n   * @param data - Entry data (hash field will be ignored)\n   * @returns Hex-encoded HMAC-SHA256 hash\n   */\n  computeHash(data: Record<string, unknown>): string {\n    // Create copy without hash field for hashing\n    const dataForHashing: Record<string, unknown> = {};\n    for (const key of Object.keys(data).sort()) {\n      if (key !== 'hash') {\n        dataForHashing[key] = data[key];\n      }\n    }\n\n    // Serialize with sorted keys for determinism\n    const serialized = JSON.stringify(dataForHashing, Object.keys(dataForHashing).sort());\n\n    // Compute HMAC\n    const hmac = createHmac(HMAC_ALGORITHM, this.hmacKey);\n    hmac.update(serialized);\n    return hmac.digest('hex');\n  }\n\n  /**\n   * Get the current chain state\n   *\n   * @returns Current sequence number and previous hash\n   */\n  getState(): ChainState {\n    return { ...this.state };\n  }\n\n  /**\n   * Set the chain state (for resuming from storage)\n   *\n   * @param state - Chain state to restore\n   */\n  setState(state: ChainState): void {\n    const result = ChainStateSchema.safeParse(state);\n    if (!result.success) {\n      throw new Error(`Invalid chain state: ${result.error.message}`);\n    }\n    this.state = { ...state };\n  }\n\n  /**\n   * Create the next entry in the chain\n   *\n   * Adds integrity fields (sequence, timestamp, previousHash, hash)\n   * to the provided data and updates the chain state.\n   *\n   * @param data - Entry data (without integrity fields)\n   * @returns Complete entry with hash chain fields\n   */\n  createEntry<T extends Record<string, unknown>>(data: T): T & HashableEntry {\n    const sequence = this.state.sequence + 1;\n    const timestamp = new Date().toISOString();\n    const previousHash = this.state.previousHash;\n\n    // Create entry with all fields\n    const entry = {\n      ...data,\n      sequence,\n      timestamp,\n      previousHash,\n      hash: '',\n    } as T & HashableEntry;\n\n    // Compute and set hash\n    entry.hash = this.computeHash(entry);\n\n    // Update chain state\n    this.state = {\n      sequence,\n      previousHash: entry.hash,\n    };\n\n    return entry;\n  }\n\n  /**\n   * Verify hash integrity of a single entry\n   *\n   * @param entry - Entry to verify\n   * @param expectedPrevHash - Expected previous hash (from prior entry or genesis)\n   * @returns Array of errors found (empty if valid)\n   */\n  verifyEntry(entry: HashableEntry, expectedPrevHash?: string): ChainError[] {\n    const errors: ChainError[] = [];\n\n    // Check previous hash chain\n    if (expectedPrevHash !== undefined && entry.previousHash !== expectedPrevHash) {\n      errors.push({\n        type: 'chain_break',\n        sequence: entry.sequence,\n        expected: expectedPrevHash,\n        actual: entry.previousHash,\n        description: `Chain break: previousHash does not match prior entry's hash`,\n      });\n    }\n\n    // Verify entry hash\n    const computedHash = this.computeHash(entry);\n    if (computedHash !== entry.hash) {\n      errors.push({\n        type: 'tampered_entry',\n        sequence: entry.sequence,\n        expected: computedHash,\n        actual: entry.hash,\n        description: `Entry hash mismatch: entry may have been tampered with`,\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Verify a sequence of entries\n   *\n   * Checks:\n   * 1. Sequence numbers are monotonic without gaps\n   * 2. Each entry's previousHash matches prior entry's hash\n   * 3. Each entry's hash can be recomputed correctly\n   * 4. Timestamps are monotonically increasing\n   *\n   * @param entries - Array of entries to verify (must be in sequence order)\n   * @param options - Verification options\n   * @returns Verification result with any detected errors\n   */\n  verifyEntries(\n    entries: HashableEntry[],\n    options: VerificationOptions = {}\n  ): ChainVerificationResult {\n    const startTime = Date.now();\n    const errors: ChainError[] = [];\n\n    if (entries.length === 0) {\n      return {\n        valid: true,\n        entriesVerified: 0,\n        startSequence: 0,\n        endSequence: 0,\n        durationMs: Date.now() - startTime,\n        errors: [],\n      };\n    }\n\n    // Get first and last entries (safe after length check)\n    const firstEntry = entries[0]!;\n    const lastEntry = entries[entries.length - 1]!;\n\n    // Determine expected previous hash for first entry\n    let expectedPrevHash: string;\n    if (firstEntry.sequence === 1) {\n      expectedPrevHash = this.computeGenesisHash();\n    } else {\n      // For partial verification, we trust the first entry's previousHash\n      // unless we have explicit starting state\n      expectedPrevHash = firstEntry.previousHash;\n    }\n\n    let expectedSequence = firstEntry.sequence;\n    let lastTimestamp = new Date(0);\n\n    for (const entry of entries) {\n      // Check 1: Sequence continuity\n      if (entry.sequence !== expectedSequence) {\n        errors.push({\n          type: 'sequence_gap',\n          sequence: entry.sequence,\n          expected: expectedSequence,\n          actual: entry.sequence,\n          description: `Expected sequence ${expectedSequence}, got ${entry.sequence}`,\n        });\n\n        if (!options.continueOnError) {\n          // Adjust expected for subsequent checks\n          expectedSequence = entry.sequence;\n        }\n      }\n\n      // Check 2: Previous hash chain\n      if (entry.previousHash !== expectedPrevHash) {\n        errors.push({\n          type: 'chain_break',\n          sequence: entry.sequence,\n          expected: expectedPrevHash,\n          actual: entry.previousHash,\n          description: `Chain break: previousHash does not match prior entry's hash`,\n        });\n      }\n\n      // Check 3: Entry hash integrity\n      const computedHash = this.computeHash(entry);\n      if (computedHash !== entry.hash) {\n        errors.push({\n          type: 'tampered_entry',\n          sequence: entry.sequence,\n          expected: computedHash,\n          actual: entry.hash,\n          description: `Entry hash mismatch: entry may have been tampered with`,\n        });\n      }\n\n      // Check 4: Timestamp ordering\n      const entryTime = new Date(entry.timestamp);\n      if (entryTime < lastTimestamp) {\n        errors.push({\n          type: 'invalid_timestamp',\n          sequence: entry.sequence,\n          expected: lastTimestamp.toISOString(),\n          actual: entry.timestamp,\n          description: `Timestamp is earlier than previous entry`,\n        });\n      }\n      lastTimestamp = entryTime;\n\n      // Update expectations for next iteration\n      expectedPrevHash = entry.hash;\n      expectedSequence = entry.sequence + 1;\n    }\n\n    return {\n      valid: errors.length === 0,\n      entriesVerified: entries.length,\n      startSequence: firstEntry.sequence,\n      endSequence: lastEntry.sequence,\n      durationMs: Date.now() - startTime,\n      errors,\n    };\n  }\n\n  /**\n   * Verify that an entry correctly links to a previous entry\n   *\n   * @param current - Current entry to verify\n   * @param previous - Previous entry in the chain\n   * @returns True if chain link is valid\n   */\n  verifyChainLink(current: HashableEntry, previous: HashableEntry): boolean {\n    return current.previousHash === previous.hash;\n  }\n\n  /**\n   * Dispose of the hash chain and zero out the HMAC key\n   *\n   * Should be called when the chain is no longer needed to\n   * prevent key material from remaining in memory.\n   */\n  dispose(): void {\n    this.hmacKey.fill(0);\n  }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Validate that an HMAC key meets requirements\n *\n * @param key - Buffer to validate\n * @returns True if key is valid\n */\nexport function isValidHmacKey(key: Buffer): boolean {\n  return HmacKeySchema.safeParse(key).success;\n}\n\n/**\n * Generate a cryptographically secure HMAC key\n *\n * @returns 256-bit HMAC key\n */\nexport function generateHmacKey(): Buffer {\n  // Use Node.js crypto for secure random generation\n  // This is imported at the top but we reference it dynamically\n  // to allow for easy mocking in tests\n  const crypto = require('crypto');\n  return crypto.randomBytes(HMAC_KEY_LENGTH);\n}\n\n/**\n * Compute a standalone HMAC-SHA256 hash (without chain state)\n *\n * @param key - HMAC key\n * @param data - Data to hash\n * @returns Hex-encoded hash\n */\nexport function computeStandaloneHash(key: Buffer, data: string): string {\n  const hmac = createHmac(HMAC_ALGORITHM, key);\n  hmac.update(data);\n  return hmac.digest('hex');\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport { GENESIS_CONSTANT, HMAC_ALGORITHM, HMAC_KEY_LENGTH };\n","/**\n * Audit Logger Implementation\n *\n * Tamper-evident audit logging with HMAC-SHA256 hash chains.\n * Stores logs in JSON Lines format with automatic integrity verification.\n *\n * @module audit/logger\n * @version 1.0.0\n * @since 2026-01-28\n */\n\nimport { createHmac, randomUUID } from 'crypto';\nimport { EventEmitter } from 'events';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { z } from 'zod';\nimport {\n  HashChain,\n  isValidHmacKey,\n  type ChainState,\n  type ChainVerificationResult,\n  type ChainError,\n  type VerificationOptions,\n  type HashableEntry,\n} from './chain.js';\nimport {\n  AuditEventTypeSchema,\n  AuditLogEntrySchema,\n  NetworkSchema,\n  TransactionTypeSchema,\n  type AuditEventType,\n  type AuditLogEntry,\n  type Network,\n  type TransactionType,\n} from '../schemas/index.js';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n/**\n * Default audit log directory relative to home\n */\nconst DEFAULT_BASE_DIR = '.xrpl-wallet-mcp';\n\n/**\n * Audit subdirectory name\n */\nconst AUDIT_SUBDIR = 'audit';\n\n/**\n * Log file prefix\n */\nconst LOG_FILE_PREFIX = 'audit-';\n\n/**\n * Log file extension (JSON Lines format)\n */\nconst LOG_FILE_EXTENSION = '.jsonl';\n\n/**\n * File permissions for audit logs (owner read/write only)\n */\nconst LOG_FILE_MODE = 0o600;\n\n/**\n * Directory permissions (owner read/write/execute only)\n */\nconst DIR_MODE = 0o700;\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Severity levels for audit events\n */\nexport type AuditSeverity = 'INFO' | 'WARN' | 'ERROR' | 'CRITICAL';\n\n/**\n * Event categories for filtering and analysis\n */\nexport type EventCategory = 'security' | 'operation' | 'transaction' | 'system';\n\n/**\n * Actor types that can trigger events\n */\nexport type ActorType = 'agent' | 'system' | 'human' | 'scheduled';\n\n/**\n * Operation result status\n */\nexport type OperationResult = 'success' | 'failure' | 'denied' | 'timeout';\n\n/**\n * Input for logging an audit event (without auto-generated fields)\n */\nexport interface AuditLogInput {\n  /** Event type from schema */\n  event: AuditEventType;\n\n  /** Wallet ID (if applicable) */\n  wallet_id?: string;\n\n  /** Wallet address (if applicable) */\n  wallet_address?: string;\n\n  /** Transaction type (if applicable) */\n  transaction_type?: TransactionType;\n\n  /** Amount in XRP (if applicable) */\n  amount_xrp?: string;\n\n  /** Destination address (if applicable) */\n  destination?: string;\n\n  /** Policy tier (if applicable) */\n  tier?: 1 | 2 | 3 | 4;\n\n  /** Policy decision */\n  policy_decision?: 'allowed' | 'denied' | 'pending';\n\n  /** Transaction hash (if applicable) */\n  tx_hash?: string;\n\n  /** Context from agent */\n  context?: string;\n}\n\n/**\n * Configuration for the AuditLogger\n */\nexport interface AuditLoggerConfig {\n  /** Base directory for audit logs */\n  baseDir: string;\n\n  /** Network (determines subdirectory) */\n  network: Network;\n\n  /** Enable synchronous writes (safer but slower) */\n  syncWrites: boolean;\n\n  /** Verify chain integrity on startup */\n  verifyOnStartup: boolean;\n\n  /** Number of recent entries to verify on startup */\n  startupVerificationEntries: number;\n}\n\n/**\n * Default configuration\n */\nexport const DEFAULT_AUDIT_LOGGER_CONFIG: AuditLoggerConfig = {\n  baseDir: path.join(process.env['HOME'] || '~', DEFAULT_BASE_DIR),\n  network: 'testnet',\n  syncWrites: true,\n  verifyOnStartup: true,\n  startupVerificationEntries: 1000,\n};\n\n/**\n * Provider interface for HMAC key\n */\nexport interface IHmacKeyProvider {\n  /** Get the HMAC key for audit logging */\n  getKey(): Promise<Buffer>;\n}\n\n/**\n * Options for creating an AuditLogger\n */\nexport interface AuditLoggerOptions {\n  /** Provider for HMAC key */\n  hmacKeyProvider: IHmacKeyProvider;\n\n  /** Configuration overrides */\n  config?: Partial<AuditLoggerConfig>;\n\n  /** Callback when tampering is detected */\n  onTamperDetected?: (result: ChainVerificationResult) => Promise<void>;\n}\n\n/**\n * Query parameters for searching audit logs\n */\nexport interface AuditLogQuery {\n  /** Start date (inclusive) */\n  startDate?: Date;\n\n  /** End date (inclusive) */\n  endDate?: Date;\n\n  /** Filter by event types */\n  eventTypes?: AuditEventType[];\n\n  /** Filter by wallet ID */\n  walletId?: string;\n\n  /** Filter by wallet address */\n  walletAddress?: string;\n\n  /** Filter by transaction hash */\n  txHash?: string;\n\n  /** Maximum results to return */\n  limit?: number;\n\n  /** Sort order */\n  sortOrder?: 'asc' | 'desc';\n}\n\n/**\n * Storage statistics\n */\nexport interface AuditStorageStats {\n  /** Total entries in current file */\n  totalEntries: number;\n\n  /** Current file size in bytes */\n  currentFileSize: number;\n\n  /** Path to current log file */\n  currentFilePath: string;\n\n  /** Oldest entry timestamp */\n  oldestEntry?: string;\n\n  /** Newest entry timestamp */\n  newestEntry?: string;\n}\n\n// ============================================================================\n// SCHEMAS\n// ============================================================================\n\n/**\n * Schema for audit log input validation\n */\nexport const AuditLogInputSchema = z.object({\n  event: AuditEventTypeSchema,\n  wallet_id: z.string().optional(),\n  wallet_address: z.string().optional(),\n  transaction_type: TransactionTypeSchema.optional(),\n  amount_xrp: z.string().optional(),\n  destination: z.string().optional(),\n  tier: z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(4)]).optional(),\n  policy_decision: z.enum(['allowed', 'denied', 'pending']).optional(),\n  tx_hash: z.string().optional(),\n  context: z.string().optional(),\n});\n\n// ============================================================================\n// SENSITIVE DATA SANITIZATION\n// ============================================================================\n\n/**\n * Fields that must NEVER appear in audit logs\n */\nconst REDACTED_FIELDS = new Set([\n  'password',\n  'seed',\n  'secret',\n  'privatekey',\n  'private_key',\n  'mnemonic',\n  'passphrase',\n  'encryptionkey',\n  'hmackey',\n  'masterkey',\n  'master_key',\n  'secretkey',\n  'secret_key',\n  'apikey',\n  'api_key',\n  'token',\n  'bearer',\n]);\n\n/**\n * Patterns that indicate sensitive data\n */\nconst SENSITIVE_PATTERNS = [\n  /^s[a-zA-Z0-9]{28}$/, // XRPL seed\n  /^[a-f0-9]{64}$/i, // 256-bit hex (private key)\n  /^[a-f0-9]{128}$/i, // 512-bit hex\n  /^(abandon\\s+){11}(abandon|about|above|absent)\\b/i, // BIP39 mnemonic start\n];\n\n/**\n * Sanitize object for logging - removes all sensitive data\n *\n * @param obj - Object to sanitize\n * @param depth - Current recursion depth\n * @returns Sanitized copy of object\n */\nexport function sanitizeForLogging(obj: unknown, depth = 0): unknown {\n  // Prevent infinite recursion\n  if (depth > 10) return '[MAX_DEPTH]';\n\n  // Handle null/undefined\n  if (obj === null || obj === undefined) return obj;\n\n  // Handle strings\n  if (typeof obj === 'string') {\n    // Check patterns\n    for (const pattern of SENSITIVE_PATTERNS) {\n      if (pattern.test(obj)) return '[REDACTED]';\n    }\n    // Truncate long strings\n    return obj.length > 1000 ? obj.slice(0, 100) + '...[TRUNCATED]' : obj;\n  }\n\n  // Handle primitives\n  if (typeof obj !== 'object') return obj;\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    return obj.map((item) => sanitizeForLogging(item, depth + 1));\n  }\n\n  // Handle objects\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {\n    const lowerKey = key.toLowerCase().replace(/[-_]/g, '');\n    if (REDACTED_FIELDS.has(lowerKey)) {\n      result[key] = '[REDACTED]';\n    } else {\n      result[key] = sanitizeForLogging(value, depth + 1);\n    }\n  }\n  return result;\n}\n\n// ============================================================================\n// AUDIT LOGGER CLASS\n// ============================================================================\n\n/**\n * AuditLogger - Tamper-evident audit logging with HMAC hash chains\n *\n * Features:\n * - HMAC-SHA256 hash chain for tamper detection\n * - JSON Lines format for append-only storage\n * - Automatic integrity verification\n * - Network-isolated log directories\n * - Sensitive data sanitization\n *\n * @example\n * ```typescript\n * const logger = await AuditLogger.create({\n *   hmacKeyProvider: { getKey: async () => myHmacKey },\n *   config: { network: 'testnet' }\n * });\n *\n * await logger.log({\n *   event: 'wallet_created',\n *   wallet_id: 'wallet-123',\n *   wallet_address: 'rAddress...'\n * });\n *\n * const result = await logger.verifyChain();\n * if (!result.valid) {\n *   console.error('Tampering detected!');\n * }\n *\n * await logger.shutdown();\n * ```\n */\nexport class AuditLogger extends EventEmitter {\n  private readonly config: AuditLoggerConfig;\n  private readonly chain: HashChain;\n  private readonly logDir: string;\n  private currentLogPath: string;\n  private isInitialized: boolean = false;\n  private writeLock: Promise<void> = Promise.resolve();\n\n  /**\n   * Private constructor - use AuditLogger.create() factory method\n   */\n  private constructor(\n    hmacKey: Buffer,\n    config: AuditLoggerConfig,\n    chainState?: ChainState\n  ) {\n    super();\n    this.config = config;\n    this.chain = new HashChain(hmacKey, chainState);\n    this.logDir = path.join(config.baseDir, config.network, AUDIT_SUBDIR);\n    this.currentLogPath = this.getLogFilePath(new Date());\n  }\n\n  /**\n   * Create and initialize an AuditLogger instance\n   *\n   * Factory method ensures proper initialization:\n   * 1. Loads HMAC key from provider\n   * 2. Creates audit directory if needed\n   * 3. Restores chain state from existing logs\n   * 4. Optionally verifies chain integrity on startup\n   *\n   * @param options - Configuration options\n   * @returns Initialized AuditLogger\n   * @throws Error if initialization fails\n   */\n  static async create(options: AuditLoggerOptions): Promise<AuditLogger> {\n    // 1. Get HMAC key\n    const hmacKey = await options.hmacKeyProvider.getKey();\n    if (!isValidHmacKey(hmacKey)) {\n      throw new Error('Invalid HMAC key: must be 32 bytes (256 bits)');\n    }\n\n    // 2. Build config\n    const config: AuditLoggerConfig = {\n      ...DEFAULT_AUDIT_LOGGER_CONFIG,\n      ...options.config,\n    };\n\n    // 3. Create instance\n    const logger = new AuditLogger(hmacKey, config);\n\n    // 4. Initialize storage\n    await logger.initialize();\n\n    // 5. Restore chain state from existing logs\n    await logger.restoreChainState();\n\n    // 6. Optional startup verification\n    if (config.verifyOnStartup) {\n      const result = await logger.verifyChain({\n        recentEntries: config.startupVerificationEntries,\n      });\n\n      if (!result.valid) {\n        logger.emit('tamper_detected', result);\n        if (options.onTamperDetected) {\n          await options.onTamperDetected(result);\n        }\n      }\n    }\n\n    return logger;\n  }\n\n  /**\n   * Initialize the audit log storage\n   */\n  private async initialize(): Promise<void> {\n    // Create directory structure\n    await fs.mkdir(this.logDir, { recursive: true, mode: DIR_MODE });\n\n    // Ensure current log file exists\n    try {\n      await fs.access(this.currentLogPath);\n    } catch {\n      // Create empty file with proper permissions\n      await fs.writeFile(this.currentLogPath, '', { mode: LOG_FILE_MODE });\n    }\n\n    this.isInitialized = true;\n  }\n\n  /**\n   * Restore chain state from existing log files\n   */\n  private async restoreChainState(): Promise<void> {\n    const lastEntry = await this.getLastEntry();\n\n    if (lastEntry) {\n      this.chain.setState({\n        sequence: lastEntry.seq,\n        previousHash: lastEntry.hash,\n      });\n    }\n  }\n\n  /**\n   * Get the log file path for a given date\n   */\n  private getLogFilePath(date: Date): string {\n    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD\n    return path.join(this.logDir, `${LOG_FILE_PREFIX}${dateStr}${LOG_FILE_EXTENSION}`);\n  }\n\n  /**\n   * Get the last entry from the current log file\n   */\n  private async getLastEntry(): Promise<AuditLogEntry | null> {\n    try {\n      const content = await fs.readFile(this.currentLogPath, 'utf-8');\n      const lines = content.trim().split('\\n').filter(Boolean);\n\n      if (lines.length === 0) {\n        return null;\n      }\n\n      const lastLine = lines[lines.length - 1]!;\n      return JSON.parse(lastLine) as AuditLogEntry;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Log an audit event\n   *\n   * @param input - Event data\n   * @returns Complete log entry with integrity fields\n   * @throws Error if logging fails\n   */\n  async log(input: AuditLogInput): Promise<AuditLogEntry> {\n    if (!this.isInitialized) {\n      throw new Error('AuditLogger not initialized. Use AuditLogger.create()');\n    }\n\n    // Validate input\n    const validated = AuditLogInputSchema.parse(input);\n\n    // Sanitize context if provided\n    const sanitizedContext = validated.context\n      ? (sanitizeForLogging(validated.context) as string)\n      : undefined;\n\n    // Serialize write operations to maintain chain integrity\n    const writePromise = this.writeLock.then(async () => {\n      // Check if we need to rotate to a new day's file\n      const today = new Date();\n      const newLogPath = this.getLogFilePath(today);\n      if (newLogPath !== this.currentLogPath) {\n        this.currentLogPath = newLogPath;\n        try {\n          await fs.access(this.currentLogPath);\n        } catch {\n          await fs.writeFile(this.currentLogPath, '', { mode: LOG_FILE_MODE });\n        }\n      }\n\n      // Build entry data (without hash chain fields)\n      const entryData = {\n        event: validated.event,\n        wallet_id: validated.wallet_id,\n        wallet_address: validated.wallet_address,\n        transaction_type: validated.transaction_type,\n        amount_xrp: validated.amount_xrp,\n        destination: validated.destination,\n        tier: validated.tier,\n        policy_decision: validated.policy_decision,\n        tx_hash: validated.tx_hash,\n        context: sanitizedContext,\n      };\n\n      // Create entry with hash chain (adds seq, timestamp, prev_hash, hash)\n      const chainEntry = this.chain.createEntry(entryData);\n\n      // Map to AuditLogEntry schema (seq instead of sequence)\n      const entry: AuditLogEntry = {\n        seq: chainEntry.sequence,\n        timestamp: chainEntry.timestamp,\n        event: chainEntry.event,\n        wallet_id: chainEntry.wallet_id,\n        wallet_address: chainEntry.wallet_address,\n        transaction_type: chainEntry.transaction_type,\n        amount_xrp: chainEntry.amount_xrp,\n        destination: chainEntry.destination,\n        tier: chainEntry.tier,\n        policy_decision: chainEntry.policy_decision,\n        tx_hash: chainEntry.tx_hash,\n        context: chainEntry.context,\n        prev_hash: chainEntry.previousHash,\n        hash: chainEntry.hash,\n      };\n\n      // Append to log file\n      const line = JSON.stringify(entry) + '\\n';\n\n      if (this.config.syncWrites) {\n        // Use synchronous write for safety\n        const handle = await fs.open(this.currentLogPath, 'a');\n        try {\n          await handle.write(line);\n          await handle.sync();\n        } finally {\n          await handle.close();\n        }\n      } else {\n        await fs.appendFile(this.currentLogPath, line);\n      }\n\n      // Emit event\n      this.emit('entry_logged', { seq: entry.seq, event: entry.event });\n\n      return entry;\n    });\n\n    this.writeLock = writePromise.then(() => {});\n    return writePromise;\n  }\n\n  /**\n   * Verify hash chain integrity\n   *\n   * @param options - Verification options\n   * @returns Verification result with any detected errors\n   */\n  async verifyChain(options: VerificationOptions = {}): Promise<ChainVerificationResult> {\n    const entries = await this.loadEntries(options);\n\n    if (entries.length === 0) {\n      return {\n        valid: true,\n        entriesVerified: 0,\n        startSequence: 0,\n        endSequence: 0,\n        durationMs: 0,\n        errors: [],\n      };\n    }\n\n    // Convert AuditLogEntry to HashableEntry format\n    const hashableEntries: HashableEntry[] = entries.map((e) => ({\n      sequence: e.seq,\n      timestamp: e.timestamp,\n      previousHash: e.prev_hash,\n      hash: e.hash,\n      event: e.event,\n      wallet_id: e.wallet_id,\n      wallet_address: e.wallet_address,\n      transaction_type: e.transaction_type,\n      amount_xrp: e.amount_xrp,\n      destination: e.destination,\n      tier: e.tier,\n      policy_decision: e.policy_decision,\n      tx_hash: e.tx_hash,\n      context: e.context,\n    }));\n\n    const result = this.chain.verifyEntries(hashableEntries, options);\n\n    if (!result.valid) {\n      this.emit('tamper_detected', result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Load entries for verification/querying\n   */\n  private async loadEntries(options: VerificationOptions = {}): Promise<AuditLogEntry[]> {\n    const entries: AuditLogEntry[] = [];\n\n    try {\n      const content = await fs.readFile(this.currentLogPath, 'utf-8');\n      const lines = content.trim().split('\\n').filter(Boolean);\n\n      for (const line of lines) {\n        try {\n          const entry = JSON.parse(line) as AuditLogEntry;\n          entries.push(entry);\n        } catch {\n          // Skip malformed lines\n          continue;\n        }\n      }\n    } catch {\n      // File doesn't exist or can't be read\n      return [];\n    }\n\n    // Apply options\n    let result = entries;\n\n    if (options.startSequence !== undefined || options.endSequence !== undefined) {\n      result = result.filter((e) => {\n        if (options.startSequence !== undefined && e.seq < options.startSequence) {\n          return false;\n        }\n        if (options.endSequence !== undefined && e.seq > options.endSequence) {\n          return false;\n        }\n        return true;\n      });\n    }\n\n    if (options.recentEntries !== undefined) {\n      result = result.slice(-options.recentEntries);\n    }\n\n    return result;\n  }\n\n  /**\n   * Query logs by criteria\n   *\n   * @param query - Query parameters\n   * @returns Matching log entries\n   */\n  async query(query: AuditLogQuery): Promise<AuditLogEntry[]> {\n    const allEntries = await this.loadEntries({});\n\n    let filtered = allEntries;\n\n    // Apply filters\n    if (query.startDate) {\n      filtered = filtered.filter((e) => new Date(e.timestamp) >= query.startDate!);\n    }\n\n    if (query.endDate) {\n      filtered = filtered.filter((e) => new Date(e.timestamp) <= query.endDate!);\n    }\n\n    if (query.eventTypes && query.eventTypes.length > 0) {\n      const eventSet = new Set(query.eventTypes);\n      filtered = filtered.filter((e) => eventSet.has(e.event));\n    }\n\n    if (query.walletId) {\n      filtered = filtered.filter((e) => e.wallet_id === query.walletId);\n    }\n\n    if (query.walletAddress) {\n      filtered = filtered.filter((e) => e.wallet_address === query.walletAddress);\n    }\n\n    if (query.txHash) {\n      filtered = filtered.filter((e) => e.tx_hash === query.txHash);\n    }\n\n    // Apply sort order\n    if (query.sortOrder === 'desc') {\n      filtered = filtered.reverse();\n    }\n\n    // Apply limit\n    if (query.limit && query.limit > 0) {\n      filtered = filtered.slice(0, query.limit);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get current chain state\n   *\n   * @returns Current sequence number and previous hash\n   */\n  getChainState(): ChainState {\n    return this.chain.getState();\n  }\n\n  /**\n   * Get storage statistics\n   *\n   * @returns Storage statistics\n   */\n  async getStats(): Promise<AuditStorageStats> {\n    const entries = await this.loadEntries({});\n\n    let fileSize = 0;\n    try {\n      const stat = await fs.stat(this.currentLogPath);\n      fileSize = stat.size;\n    } catch {\n      // File doesn't exist\n    }\n\n    const stats: AuditStorageStats = {\n      totalEntries: entries.length,\n      currentFileSize: fileSize,\n      currentFilePath: this.currentLogPath,\n    };\n\n    if (entries.length > 0) {\n      const firstEntry = entries[0]!;\n      const lastEntry = entries[entries.length - 1]!;\n      stats.oldestEntry = firstEntry.timestamp;\n      stats.newestEntry = lastEntry.timestamp;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Graceful shutdown\n   *\n   * Ensures all pending writes complete and disposes of the hash chain.\n   *\n   * @param timeout - Maximum wait time for pending writes (ms)\n   */\n  async shutdown(timeout = 5000): Promise<void> {\n    // Wait for pending writes\n    const timeoutPromise = new Promise<void>((_, reject) => {\n      setTimeout(() => reject(new Error('Shutdown timeout')), timeout);\n    });\n\n    try {\n      await Promise.race([this.writeLock, timeoutPromise]);\n    } catch {\n      // Timeout or error - continue with shutdown\n    }\n\n    // Dispose of hash chain (zeros HMAC key)\n    this.chain.dispose();\n\n    // Emit shutdown event\n    this.emit('shutdown');\n  }\n}\n\n// ============================================================================\n// CONVENIENCE FUNCTIONS\n// ============================================================================\n\n/**\n * Create an in-memory HMAC key provider for testing\n *\n * @param key - HMAC key buffer\n * @returns HMAC key provider\n */\nexport function createMemoryKeyProvider(key: Buffer): IHmacKeyProvider {\n  return {\n    getKey: async () => key,\n  };\n}\n\n/**\n * Get the default audit log directory for a network\n *\n * @param network - XRPL network\n * @returns Directory path\n */\nexport function getDefaultAuditDir(network: Network): string {\n  const baseDir = path.join(process.env['HOME'] || '~', DEFAULT_BASE_DIR);\n  return path.join(baseDir, network, AUDIT_SUBDIR);\n}\n","/**\n * Policy Engine Type Definitions\n *\n * Core types for policy evaluation, rule matching, and tier classification.\n * These types support the OPA-inspired policy engine for the XRPL Agent Wallet.\n *\n * @module policy/types\n * @version 1.0.0\n */\n\nimport { z } from 'zod';\nimport type {\n  TransactionType,\n  ApprovalTier,\n  AgentWalletPolicy,\n} from '../schemas/index.js';\n\n// ============================================================================\n// TIER TYPES\n// ============================================================================\n\n/**\n * String representation of approval tiers for policy engine internal use.\n * Maps to ApprovalTier (1-4) for external API.\n */\nexport type Tier = 'autonomous' | 'delayed' | 'cosign' | 'prohibited';\n\n/**\n * Convert string tier to numeric ApprovalTier\n */\nexport function tierToNumeric(tier: Tier): ApprovalTier {\n  const map: Record<Tier, ApprovalTier> = {\n    autonomous: 1,\n    delayed: 2,\n    cosign: 3,\n    prohibited: 4,\n  };\n  return map[tier];\n}\n\n/**\n * Convert numeric ApprovalTier to string tier\n */\nexport function numericToTier(tier: ApprovalTier): Tier {\n  const map: Record<ApprovalTier, Tier> = {\n    1: 'autonomous',\n    2: 'delayed',\n    3: 'cosign',\n    4: 'prohibited',\n  };\n  return map[tier];\n}\n\n// ============================================================================\n// POLICY CONTEXT\n// ============================================================================\n\n/**\n * Transaction context for policy evaluation.\n * Contains all fields that can be used in policy conditions.\n */\nexport interface TransactionContext {\n  /** XRPL transaction type */\n  type: TransactionType;\n  /** Destination address (if applicable) */\n  destination?: string;\n  /** Amount in XRP */\n  amount_xrp?: number;\n  /** Amount in drops */\n  amount_drops?: bigint;\n  /** Memo content (text) */\n  memo?: string;\n  /** Memo type field */\n  memo_type?: string;\n  /** Transaction fee in drops */\n  fee_drops?: number;\n  /** Destination tag */\n  destination_tag?: number;\n  /** Source tag */\n  source_tag?: number;\n  /** Currency code (for issued currencies) */\n  currency?: string;\n  /** Token issuer address */\n  issuer?: string;\n}\n\n/**\n * Wallet context for policy evaluation.\n */\nexport interface WalletContext {\n  /** Wallet's XRPL address */\n  address: string;\n  /** Network the wallet operates on */\n  network: 'mainnet' | 'testnet' | 'devnet';\n}\n\n/**\n * Complete context for policy evaluation.\n */\nexport interface PolicyContext {\n  /** Transaction being evaluated */\n  transaction: TransactionContext;\n  /** Wallet making the transaction */\n  wallet: WalletContext;\n  /** Evaluation timestamp */\n  timestamp: Date;\n  /** Correlation ID for audit trail */\n  correlationId: string;\n}\n\n// ============================================================================\n// POLICY RESULT TYPES\n// ============================================================================\n\n/**\n * Factor that contributed to tier determination.\n */\nexport interface TierFactor {\n  /** What triggered this factor */\n  source:\n    | 'rule'\n    | 'transaction_type'\n    | 'amount_limit'\n    | 'new_destination'\n    | 'prohibited_type'\n    | 'blocklist'\n    | 'limit_exceeded'\n    | 'time_control';\n  /** Tier this factor suggests */\n  tier: Tier;\n  /** Explanation */\n  reason: string;\n}\n\n/**\n * Complete policy evaluation result.\n */\nexport interface PolicyResult {\n  /** Whether transaction can proceed (in some form) */\n  allowed: boolean;\n  /** Assigned tier determining approval workflow */\n  tier: Tier;\n  /** Numeric tier for API responses */\n  tierNumeric: ApprovalTier;\n  /** Human-readable explanation */\n  reason: string;\n  /** ID of the rule that matched */\n  matchedRule: string;\n  /** Contributing factors to tier determination */\n  factors?: TierFactor[];\n  /** Evaluation duration in milliseconds */\n  evaluationTimeMs?: number;\n\n  // Tier-specific fields\n\n  /** Delay in seconds (for delayed tier) */\n  delaySeconds?: number;\n  /** Whether veto is possible (for delayed tier) */\n  vetoEnabled?: boolean;\n  /** Required signatures (for cosign tier) */\n  signerQuorum?: number;\n  /** Approval timeout (for cosign tier) */\n  approvalTimeoutHours?: number;\n  /** Authorized signer addresses (for cosign tier) */\n  signerAddresses?: string[];\n  /** Whether to send notification */\n  notify?: boolean;\n  /** Prompt injection detected in memo */\n  injectionDetected?: boolean;\n}\n\n// ============================================================================\n// RULE TYPES\n// ============================================================================\n\n/**\n * Operators for condition evaluation.\n */\nexport type Operator =\n  | '=='\n  | '!='\n  | '>'\n  | '>='\n  | '<'\n  | '<='\n  | 'in'\n  | 'not_in'\n  | 'matches'\n  | 'contains'\n  | 'starts_with'\n  | 'ends_with'\n  | 'in_category';\n\n/**\n * Reference to a policy list (blocklist/allowlist).\n */\nexport interface ValueReference {\n  ref: string;\n}\n\n/**\n * Simple field condition.\n */\nexport interface FieldCondition {\n  field: string;\n  operator: Operator;\n  value: unknown | ValueReference;\n}\n\n/**\n * Logical AND condition.\n */\nexport interface AndCondition {\n  and: Condition[];\n}\n\n/**\n * Logical OR condition.\n */\nexport interface OrCondition {\n  or: Condition[];\n}\n\n/**\n * Logical NOT condition.\n */\nexport interface NotCondition {\n  not: Condition;\n}\n\n/**\n * Always-true condition (for default rules).\n */\nexport interface AlwaysCondition {\n  always: true;\n}\n\n/**\n * Union of all condition types.\n */\nexport type Condition =\n  | FieldCondition\n  | AndCondition\n  | OrCondition\n  | NotCondition\n  | AlwaysCondition;\n\n/**\n * Rule action - what tier to assign.\n */\nexport interface RuleAction {\n  tier: Tier;\n  reason?: string;\n  override_delay_seconds?: number;\n  notify?: boolean;\n  log_level?: 'info' | 'warn' | 'error';\n}\n\n/**\n * Policy rule definition.\n */\nexport interface PolicyRule {\n  id: string;\n  name: string;\n  description?: string;\n  priority: number;\n  enabled?: boolean;\n  condition: Condition;\n  action: RuleAction;\n}\n\n// ============================================================================\n// LIMIT TYPES\n// ============================================================================\n\n/**\n * Limit check result.\n */\nexport interface LimitCheckResult {\n  /** Whether limit was exceeded */\n  exceeded: boolean;\n  /** Human-readable reason */\n  reason?: string;\n  /** Type of limit exceeded */\n  limitType?:\n    | 'daily_count'\n    | 'hourly_count'\n    | 'daily_volume'\n    | 'unique_destinations'\n    | 'cooldown'\n    | 'per_tx_amount';\n  /** Current value */\n  currentValue?: number;\n  /** Limit value */\n  limitValue?: number;\n  /** Requested amount (if volume limit) */\n  requestedAmount?: number;\n  /** When limit resets */\n  expiresAt?: Date;\n}\n\n/**\n * Current limit state for monitoring.\n */\nexport interface LimitState {\n  daily: {\n    date: string;\n    transactionCount: number;\n    totalVolumeXrp: number;\n    uniqueDestinations: Set<string>;\n    lastTransactionTime: Date | null;\n  };\n  hourly: {\n    transactions: Array<{\n      timestamp: Date;\n      amountXrp: number;\n      destination: string;\n    }>;\n  };\n  cooldown: {\n    active: boolean;\n    reason: string | null;\n    expiresAt: Date | null;\n    triggeredBy: string | null;\n  };\n}\n\n/**\n * Limit configuration.\n */\nexport interface LimitConfig {\n  dailyResetHour: number;\n  maxTransactionsPerHour: number;\n  maxTransactionsPerDay: number;\n  maxUniqueDestinationsPerDay?: number | undefined;\n  maxTotalVolumeXrpPerDay: number;\n  maxAmountPerTxXrp?: number | undefined;\n  cooldownAfterHighValue?: {\n    enabled: boolean;\n    thresholdXrp: number;\n    cooldownSeconds: number;\n  } | undefined;\n}\n\n// ============================================================================\n// POLICY INFO & METADATA\n// ============================================================================\n\n/**\n * Policy metadata (safe to expose).\n */\nexport interface PolicyInfo {\n  name: string;\n  version: string;\n  network: string;\n  description?: string | undefined;\n  enabled: boolean;\n  loadedAt: Date;\n  hash: string;\n  ruleCount: number;\n  enabledRuleCount: number;\n}\n\n// ============================================================================\n// COMPILED RULE TYPE\n// ============================================================================\n\n/**\n * Function type for condition evaluation.\n */\nexport type ConditionEvaluator = (\n  context: PolicyContext,\n  policy: InternalPolicy\n) => boolean;\n\n/**\n * Compiled rule for efficient evaluation.\n */\nexport interface CompiledRule {\n  id: string;\n  name: string;\n  priority: number;\n  evaluator: ConditionEvaluator;\n  action: RuleAction;\n}\n\n// ============================================================================\n// INTERNAL POLICY STRUCTURE\n// ============================================================================\n\n/**\n * Internal policy structure used by the engine.\n * Extended from AgentWalletPolicy with additional fields.\n */\nexport interface InternalPolicy {\n  version: string;\n  name: string;\n  description?: string;\n  network: 'mainnet' | 'testnet' | 'devnet';\n  enabled: boolean;\n\n  tiers: {\n    autonomous?: {\n      max_amount_xrp: number;\n      daily_limit_xrp?: number;\n      require_known_destination?: boolean;\n      allowed_transaction_types?: TransactionType[];\n      max_fee_drops?: number;\n    };\n    delayed?: {\n      max_amount_xrp: number;\n      daily_limit_xrp?: number;\n      delay_seconds: number;\n      veto_enabled?: boolean;\n      notify_on_queue?: boolean;\n    };\n    cosign?: {\n      min_amount_xrp?: number;\n      new_destination_always?: boolean;\n      signer_quorum: number;\n      approval_timeout_hours?: number;\n      notify_signers?: boolean;\n      signer_addresses?: string[];\n    };\n    prohibited?: {\n      reasons?: string[];\n      prohibited_transaction_types?: TransactionType[];\n    };\n  };\n\n  rules: PolicyRule[];\n\n  blocklist?: {\n    addresses?: string[];\n    memo_patterns?: string[];\n    currency_issuers?: string[];\n  };\n\n  allowlist?: {\n    addresses?: string[];\n    trusted_tags?: number[];\n    auto_learn?: boolean;\n    exchange_addresses?: Array<{\n      address: string;\n      name?: string;\n      require_tag?: boolean;\n    }>;\n  };\n\n  limits: {\n    daily_reset_utc_hour?: number;\n    max_transactions_per_hour: number;\n    max_transactions_per_day: number;\n    max_unique_destinations_per_day?: number;\n    max_total_volume_xrp_per_day: number;\n    cooldown_after_high_value?: {\n      enabled: boolean;\n      threshold_xrp: number;\n      cooldown_seconds: number;\n    };\n  };\n\n  transaction_types?: Record<\n    TransactionType,\n    {\n      enabled?: boolean;\n      default_tier?: Tier;\n      max_amount_xrp?: number;\n      require_cosign?: boolean;\n    }\n  >;\n}\n\n// ============================================================================\n// POLICY ENGINE OPTIONS\n// ============================================================================\n\n/**\n * Options for PolicyEngine constructor.\n */\nexport interface PolicyEngineOptions {\n  /** Path for persisting limit state across restarts */\n  limitPersistencePath?: string;\n  /** Watch policy file for changes and log warnings */\n  watchForChanges?: boolean;\n  /** Custom clock for testing time-dependent logic */\n  clock?: () => Date;\n  /** Maximum regex execution time in milliseconds (ReDoS protection) */\n  regexTimeoutMs?: number;\n}\n\n// ============================================================================\n// ERROR TYPES\n// ============================================================================\n\n/**\n * Base error for policy-related failures.\n */\nexport class PolicyError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly recoverable: boolean = false\n  ) {\n    super(message);\n    this.name = 'PolicyError';\n  }\n\n  toJSON(): object {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n      recoverable: this.recoverable,\n    };\n  }\n}\n\n/**\n * Policy file loading failed.\n */\nexport class PolicyLoadError extends PolicyError {\n  constructor(message: string) {\n    super(message, 'POLICY_LOAD_ERROR', false);\n    this.name = 'PolicyLoadError';\n  }\n}\n\n/**\n * Policy validation against schema failed.\n */\nexport class PolicyValidationError extends PolicyError {\n  constructor(\n    message: string,\n    public readonly issues: z.ZodIssue[]\n  ) {\n    super(message, 'POLICY_VALIDATION_ERROR', false);\n    this.name = 'PolicyValidationError';\n  }\n}\n\n/**\n * Error during policy evaluation.\n */\nexport class PolicyEvaluationError extends PolicyError {\n  constructor(message: string) {\n    super(message, 'POLICY_EVALUATION_ERROR', true);\n    this.name = 'PolicyEvaluationError';\n  }\n}\n\n/**\n * Policy integrity check failed.\n */\nexport class PolicyIntegrityError extends PolicyError {\n  constructor() {\n    super('Policy integrity verification failed', 'POLICY_INTEGRITY_ERROR', false);\n    this.name = 'PolicyIntegrityError';\n  }\n}\n\n/**\n * Limit exceeded error.\n */\nexport class LimitExceededError extends PolicyError {\n  constructor(\n    message: string,\n    public readonly limitType: string,\n    public readonly currentValue: number,\n    public readonly limitValue: number\n  ) {\n    super(message, 'LIMIT_EXCEEDED', true);\n    this.name = 'LimitExceededError';\n  }\n}\n","/**\n * Rule Evaluator Implementation\n *\n * Priority-based rule matching with condition compilation for\n * efficient policy evaluation.\n *\n * @module policy/evaluator\n * @version 1.0.0\n */\n\nimport type {\n  PolicyContext,\n  InternalPolicy,\n  PolicyRule,\n  Condition,\n  FieldCondition,\n  AndCondition,\n  OrCondition,\n  NotCondition,\n  AlwaysCondition,\n  ValueReference,\n  Operator,\n  ConditionEvaluator,\n  CompiledRule,\n  RuleAction,\n  Tier,\n} from './types.js';\nimport { PolicyEvaluationError } from './types.js';\nimport type { TransactionType } from '../schemas/index.js';\n\n// ============================================================================\n// TRANSACTION CATEGORIES\n// ============================================================================\n\n/**\n * Map transaction types to categories for in_category operator.\n */\nconst TRANSACTION_CATEGORIES: Record<string, string> = {\n  // Payments\n  Payment: 'payments',\n\n  // Trustlines\n  TrustSet: 'trustlines',\n\n  // DEX\n  OfferCreate: 'dex',\n  OfferCancel: 'dex',\n\n  // Escrow\n  EscrowCreate: 'escrow',\n  EscrowFinish: 'escrow',\n  EscrowCancel: 'escrow',\n\n  // Payment Channels\n  PaymentChannelCreate: 'paychan',\n  PaymentChannelFund: 'paychan',\n  PaymentChannelClaim: 'paychan',\n\n  // Account\n  AccountSet: 'account',\n  AccountDelete: 'account',\n  SetRegularKey: 'account',\n  SignerListSet: 'account',\n  DepositPreauth: 'account',\n\n  // NFT\n  NFTokenMint: 'nft',\n  NFTokenBurn: 'nft',\n  NFTokenCreateOffer: 'nft',\n  NFTokenCancelOffer: 'nft',\n  NFTokenAcceptOffer: 'nft',\n\n  // AMM\n  AMMCreate: 'amm',\n  AMMDeposit: 'amm',\n  AMMWithdraw: 'amm',\n  AMMVote: 'amm',\n  AMMBid: 'amm',\n  AMMDelete: 'amm',\n\n  // Checks\n  CheckCreate: 'checks',\n  CheckCash: 'checks',\n  CheckCancel: 'checks',\n\n  // Tickets\n  TicketCreate: 'tickets',\n\n  // Clawback\n  Clawback: 'clawback',\n\n  // DID\n  DIDSet: 'did',\n  DIDDelete: 'did',\n\n  // Cross-chain\n  XChainAccountCreateCommit: 'xchain',\n  XChainAddClaimAttestation: 'xchain',\n  XChainClaim: 'xchain',\n  XChainCommit: 'xchain',\n  XChainCreateBridge: 'xchain',\n  XChainCreateClaimID: 'xchain',\n  XChainModifyBridge: 'xchain',\n};\n\n/**\n * Get transaction category for a transaction type.\n */\nexport function getTransactionCategory(type: string): string {\n  return TRANSACTION_CATEGORIES[type] ?? 'unknown';\n}\n\n// ============================================================================\n// RULE EVALUATOR\n// ============================================================================\n\n/**\n * Result of rule evaluation.\n */\nexport interface RuleResult {\n  matched: boolean;\n  ruleId: string;\n  ruleName: string;\n  tier: Tier;\n  reason: string;\n  overrideDelaySeconds?: number | undefined;\n  notify?: boolean | undefined;\n  logLevel?: 'info' | 'warn' | 'error' | undefined;\n}\n\n/**\n * Options for RuleEvaluator.\n */\nexport interface RuleEvaluatorOptions {\n  /** Maximum regex execution time in ms (ReDoS protection) */\n  regexTimeoutMs?: number;\n  /** Maximum input length for regex matching */\n  maxRegexInputLength?: number;\n}\n\n/**\n * Evaluates policy rules in priority order.\n *\n * Features:\n * - Rule compilation for efficient repeated evaluation\n * - Priority-based evaluation (lower = higher priority)\n * - Logical operators (AND, OR, NOT)\n * - Field comparisons with multiple operators\n * - Reference resolution for blocklist/allowlist\n * - Regex caching with ReDoS protection\n */\nexport class RuleEvaluator {\n  private readonly compiledRules: Map<string, CompiledRule> = new Map();\n  private readonly regexCache: Map<string, RegExp> = new Map();\n  private readonly options: Required<RuleEvaluatorOptions>;\n\n  constructor(options?: RuleEvaluatorOptions) {\n    this.options = {\n      regexTimeoutMs: options?.regexTimeoutMs ?? 100,\n      maxRegexInputLength: options?.maxRegexInputLength ?? 10000,\n    };\n  }\n\n  /**\n   * Compile rules for efficient evaluation.\n   * Rules are sorted by priority (lower = higher priority).\n   */\n  compileRules(rules: PolicyRule[]): void {\n    this.compiledRules.clear();\n\n    // Filter enabled rules and sort by priority\n    const enabledRules = rules\n      .filter((rule) => rule.enabled !== false)\n      .sort((a, b) => a.priority - b.priority);\n\n    for (const rule of enabledRules) {\n      const compiled = this.compileRule(rule);\n      this.compiledRules.set(rule.id, compiled);\n    }\n  }\n\n  /**\n   * Compile a single rule.\n   */\n  private compileRule(rule: PolicyRule): CompiledRule {\n    return {\n      id: rule.id,\n      name: rule.name,\n      priority: rule.priority,\n      evaluator: this.compileCondition(rule.condition),\n      action: rule.action,\n    };\n  }\n\n  /**\n   * Compile a condition into an evaluator function.\n   */\n  private compileCondition(condition: Condition): ConditionEvaluator {\n    // Always condition\n    if (this.isAlwaysCondition(condition)) {\n      return () => true;\n    }\n\n    // Logical AND\n    if (this.isAndCondition(condition)) {\n      const subEvaluators = condition.and.map((c) => this.compileCondition(c));\n      return (ctx, policy) => subEvaluators.every((evaluator) => evaluator(ctx, policy));\n    }\n\n    // Logical OR\n    if (this.isOrCondition(condition)) {\n      const subEvaluators = condition.or.map((c) => this.compileCondition(c));\n      return (ctx, policy) => subEvaluators.some((evaluator) => evaluator(ctx, policy));\n    }\n\n    // Logical NOT\n    if (this.isNotCondition(condition)) {\n      const subEvaluator = this.compileCondition(condition.not);\n      return (ctx, policy) => !subEvaluator(ctx, policy);\n    }\n\n    // Field condition\n    if (this.isFieldCondition(condition)) {\n      return this.compileFieldCondition(condition);\n    }\n\n    throw new PolicyEvaluationError(\n      `Unknown condition type: ${JSON.stringify(condition)}`\n    );\n  }\n\n  /**\n   * Compile a field condition.\n   */\n  private compileFieldCondition(condition: FieldCondition): ConditionEvaluator {\n    const { field, operator, value } = condition;\n\n    return (context: PolicyContext, policy: InternalPolicy) => {\n      // Extract field value from context\n      const fieldValue = this.extractFieldValue(field, context, policy);\n\n      // Resolve value (may be a reference to policy lists)\n      const compareValue = this.resolveValue(value, policy);\n\n      // Evaluate operator\n      return this.evaluateOperator(operator, fieldValue, compareValue);\n    };\n  }\n\n  /**\n   * Extract a field value from the policy context.\n   */\n  private extractFieldValue(\n    field: string,\n    context: PolicyContext,\n    policy: InternalPolicy\n  ): unknown {\n    switch (field) {\n      // Transaction fields\n      case 'destination':\n        return context.transaction.destination;\n      case 'amount_xrp':\n        return context.transaction.amount_xrp ?? 0;\n      case 'amount_drops':\n        return context.transaction.amount_drops ?? 0n;\n      case 'transaction_type':\n        return context.transaction.type;\n      case 'transaction_category':\n        return getTransactionCategory(context.transaction.type);\n      case 'memo':\n        return context.transaction.memo ?? '';\n      case 'memo_type':\n        return context.transaction.memo_type ?? '';\n      case 'fee_drops':\n        return context.transaction.fee_drops ?? 0;\n      case 'destination_tag':\n        return context.transaction.destination_tag;\n      case 'source_tag':\n        return context.transaction.source_tag;\n      case 'currency':\n        return context.transaction.currency;\n      case 'issuer':\n        return context.transaction.issuer;\n\n      // Wallet fields\n      case 'wallet_address':\n        return context.wallet.address;\n      case 'network':\n        return context.wallet.network;\n\n      // Derived fields\n      case 'is_new_destination':\n        // This requires limit tracker integration\n        // For now, check against allowlist\n        if (!context.transaction.destination) return false;\n        const allowlist = policy.allowlist?.addresses ?? [];\n        return !allowlist.includes(context.transaction.destination);\n\n      default:\n        throw new PolicyEvaluationError(`Unknown field: ${field}`);\n    }\n  }\n\n  /**\n   * Resolve a value (may be a reference to policy lists).\n   */\n  private resolveValue(value: unknown, policy: InternalPolicy): unknown {\n    // Check if value is a reference\n    if (this.isValueReference(value)) {\n      return this.resolveReference(value.ref, policy);\n    }\n    return value;\n  }\n\n  /**\n   * Resolve a reference to a policy list.\n   */\n  private resolveReference(ref: string, policy: InternalPolicy): unknown {\n    switch (ref) {\n      case 'blocklist.addresses':\n        return policy.blocklist?.addresses ?? [];\n      case 'blocklist.memo_patterns':\n        return policy.blocklist?.memo_patterns ?? [];\n      case 'blocklist.currency_issuers':\n        return policy.blocklist?.currency_issuers ?? [];\n      case 'allowlist.addresses':\n        return policy.allowlist?.addresses ?? [];\n      case 'allowlist.trusted_tags':\n        return policy.allowlist?.trusted_tags ?? [];\n      default:\n        throw new PolicyEvaluationError(`Unknown reference: ${ref}`);\n    }\n  }\n\n  /**\n   * Evaluate an operator.\n   */\n  private evaluateOperator(\n    operator: Operator,\n    fieldValue: unknown,\n    compareValue: unknown\n  ): boolean {\n    switch (operator) {\n      // Equality operators\n      case '==':\n        return fieldValue === compareValue;\n      case '!=':\n        return fieldValue !== compareValue;\n\n      // Numeric comparison operators\n      case '>':\n        return this.asNumber(fieldValue) > this.asNumber(compareValue);\n      case '>=':\n        return this.asNumber(fieldValue) >= this.asNumber(compareValue);\n      case '<':\n        return this.asNumber(fieldValue) < this.asNumber(compareValue);\n      case '<=':\n        return this.asNumber(fieldValue) <= this.asNumber(compareValue);\n\n      // Array operators\n      case 'in':\n        return this.asArray(compareValue).includes(fieldValue);\n      case 'not_in':\n        return !this.asArray(compareValue).includes(fieldValue);\n\n      // String operators\n      case 'matches':\n        return this.matchesRegex(this.asString(fieldValue), this.asString(compareValue));\n      case 'contains':\n        return this.asString(fieldValue).includes(this.asString(compareValue));\n      case 'starts_with':\n        return this.asString(fieldValue).startsWith(this.asString(compareValue));\n      case 'ends_with':\n        return this.asString(fieldValue).endsWith(this.asString(compareValue));\n\n      // Category operator\n      case 'in_category':\n        return this.isInCategory(this.asString(fieldValue), this.asString(compareValue));\n\n      default:\n        throw new PolicyEvaluationError(`Unknown operator: ${operator}`);\n    }\n  }\n\n  /**\n   * Match a value against a regex pattern.\n   */\n  private matchesRegex(value: string, pattern: string): boolean {\n    // Get or compile regex\n    let regex = this.regexCache.get(pattern);\n    if (!regex) {\n      try {\n        regex = new RegExp(pattern, 'i');\n        this.regexCache.set(pattern, regex);\n      } catch (error) {\n        throw new PolicyEvaluationError(`Invalid regex pattern: ${pattern}`);\n      }\n    }\n\n    // Limit input length for ReDoS protection\n    const truncatedValue =\n      value.length > this.options.maxRegexInputLength\n        ? value.slice(0, this.options.maxRegexInputLength)\n        : value;\n\n    return regex.test(truncatedValue);\n  }\n\n  /**\n   * Check if a transaction type is in a category.\n   */\n  private isInCategory(txType: string, category: string): boolean {\n    return getTransactionCategory(txType) === category;\n  }\n\n  // ============================================================================\n  // TYPE GUARDS\n  // ============================================================================\n\n  private isAlwaysCondition(condition: Condition): condition is AlwaysCondition {\n    return 'always' in condition && condition.always === true;\n  }\n\n  private isAndCondition(condition: Condition): condition is AndCondition {\n    return 'and' in condition;\n  }\n\n  private isOrCondition(condition: Condition): condition is OrCondition {\n    return 'or' in condition;\n  }\n\n  private isNotCondition(condition: Condition): condition is NotCondition {\n    return 'not' in condition;\n  }\n\n  private isFieldCondition(condition: Condition): condition is FieldCondition {\n    return 'field' in condition;\n  }\n\n  private isValueReference(value: unknown): value is ValueReference {\n    return (\n      typeof value === 'object' &&\n      value !== null &&\n      'ref' in value &&\n      typeof (value as ValueReference).ref === 'string'\n    );\n  }\n\n  // ============================================================================\n  // TYPE CONVERSIONS\n  // ============================================================================\n\n  private asNumber(value: unknown): number {\n    if (typeof value === 'number') return value;\n    if (typeof value === 'bigint') return Number(value);\n    if (typeof value === 'string') {\n      const parsed = parseFloat(value);\n      if (isNaN(parsed)) {\n        throw new PolicyEvaluationError(`Cannot convert \"${value}\" to number`);\n      }\n      return parsed;\n    }\n    throw new PolicyEvaluationError(`Cannot convert ${typeof value} to number`);\n  }\n\n  private asString(value: unknown): string {\n    if (typeof value === 'string') return value;\n    if (value === null || value === undefined) return '';\n    return String(value);\n  }\n\n  private asArray(value: unknown): unknown[] {\n    if (Array.isArray(value)) return value;\n    throw new PolicyEvaluationError(`Expected array, got ${typeof value}`);\n  }\n\n  // ============================================================================\n  // PUBLIC EVALUATION METHODS\n  // ============================================================================\n\n  /**\n   * Evaluate rules against a context.\n   * Returns the first matching rule's result.\n   */\n  evaluate(context: PolicyContext, policy: InternalPolicy): RuleResult {\n    // Rules are pre-sorted by priority during compilation\n    for (const [ruleId, compiled] of this.compiledRules) {\n      try {\n        const matches = compiled.evaluator(context, policy);\n\n        if (matches) {\n          return {\n            matched: true,\n            ruleId: compiled.id,\n            ruleName: compiled.name,\n            tier: compiled.action.tier,\n            reason: compiled.action.reason ?? `Matched rule: ${compiled.name}`,\n            overrideDelaySeconds: compiled.action.override_delay_seconds,\n            notify: compiled.action.notify,\n            logLevel: compiled.action.log_level,\n          };\n        }\n      } catch (error) {\n        // Log error but continue to next rule\n        // Fail-secure: if rule evaluation errors, don't match it\n        console.error(`Rule evaluation error for ${ruleId}:`, error);\n      }\n    }\n\n    // No rule matched - default deny\n    return {\n      matched: false,\n      ruleId: 'default-deny',\n      ruleName: 'No matching rule',\n      tier: 'prohibited',\n      reason: 'No matching rule (default deny)',\n    };\n  }\n\n  /**\n   * Get the number of compiled rules.\n   */\n  getRuleCount(): number {\n    return this.compiledRules.size;\n  }\n\n  /**\n   * Clear compiled rules and caches.\n   */\n  clear(): void {\n    this.compiledRules.clear();\n    this.regexCache.clear();\n  }\n}\n\n// ============================================================================\n// BLOCKLIST CHECKER\n// ============================================================================\n\n/**\n * Check if a transaction matches blocklist criteria.\n */\nexport interface BlocklistCheckResult {\n  blocked: boolean;\n  reason?: string;\n  matchedRule?: string;\n  injectionDetected?: boolean;\n}\n\n/**\n * Check transaction against blocklist.\n *\n * This is a separate check from rule evaluation because\n * blocklist should ALWAYS be checked first, regardless of rules.\n */\nexport function checkBlocklist(\n  context: PolicyContext,\n  policy: InternalPolicy,\n  regexCache?: Map<string, RegExp>\n): BlocklistCheckResult {\n  const blocklist = policy.blocklist;\n  if (!blocklist) {\n    return { blocked: false };\n  }\n\n  // Check destination address\n  if (\n    context.transaction.destination &&\n    blocklist.addresses?.includes(context.transaction.destination)\n  ) {\n    return {\n      blocked: true,\n      reason: 'Destination address is blocklisted',\n      matchedRule: 'blocklist-address',\n    };\n  }\n\n  // Check currency issuer\n  if (\n    context.transaction.issuer &&\n    blocklist.currency_issuers?.includes(context.transaction.issuer)\n  ) {\n    return {\n      blocked: true,\n      reason: 'Token issuer is blocklisted',\n      matchedRule: 'blocklist-issuer',\n    };\n  }\n\n  // Check memo patterns (prompt injection detection)\n  if (context.transaction.memo && blocklist.memo_patterns?.length) {\n    const cache = regexCache ?? new Map<string, RegExp>();\n\n    for (const pattern of blocklist.memo_patterns) {\n      let regex = cache.get(pattern);\n      if (!regex) {\n        try {\n          regex = new RegExp(pattern, 'i');\n          cache.set(pattern, regex);\n        } catch {\n          // Invalid regex pattern - skip\n          continue;\n        }\n      }\n\n      // Limit memo length for ReDoS protection\n      const memo =\n        context.transaction.memo.length > 10000\n          ? context.transaction.memo.slice(0, 10000)\n          : context.transaction.memo;\n\n      if (regex.test(memo)) {\n        return {\n          blocked: true,\n          reason: 'Memo contains blocked pattern (potential injection)',\n          matchedRule: 'blocklist-memo-pattern',\n          injectionDetected: true,\n        };\n      }\n    }\n  }\n\n  return { blocked: false };\n}\n\n/**\n * Check if a destination is in the allowlist.\n */\nexport function isInAllowlist(\n  context: PolicyContext,\n  policy: InternalPolicy\n): boolean {\n  const allowlist = policy.allowlist;\n  if (!allowlist) return false;\n\n  // Check if destination is in allowlist\n  if (\n    context.transaction.destination &&\n    allowlist.addresses?.includes(context.transaction.destination)\n  ) {\n    return true;\n  }\n\n  // Check exchange addresses with special handling\n  if (context.transaction.destination && allowlist.exchange_addresses) {\n    const exchange = allowlist.exchange_addresses.find(\n      (ex) => ex.address === context.transaction.destination\n    );\n    if (exchange) {\n      // Exchange addresses may require destination tag\n      if (exchange.require_tag && !context.transaction.destination_tag) {\n        return false; // Missing required tag\n      }\n      return true;\n    }\n  }\n\n  // Check trusted tags\n  if (\n    context.transaction.destination_tag !== undefined &&\n    allowlist.trusted_tags?.includes(context.transaction.destination_tag)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * Limit Tracker Implementation\n *\n * Token bucket rate limiting with rolling window counters for\n * transaction count, volume, and destination tracking.\n *\n * @module policy/limits\n * @version 1.0.0\n */\n\nimport type {\n  LimitConfig,\n  LimitState,\n  LimitCheckResult,\n  PolicyContext,\n} from './types.js';\n\n// ============================================================================\n// LIMIT TRACKER\n// ============================================================================\n\n/**\n * Options for LimitTracker construction.\n */\nexport interface LimitTrackerOptions {\n  /** Limit configuration */\n  config: LimitConfig;\n  /** Path for persisting state (optional) */\n  persistencePath?: string | undefined;\n  /** Custom clock for testing */\n  clock?: (() => Date) | undefined;\n}\n\n/**\n * Tracks transaction limits using rolling windows and daily resets.\n *\n * Features:\n * - Daily transaction count limits (resets at configured UTC hour)\n * - Hourly transaction count limits (sliding 1-hour window)\n * - Daily XRP volume limits\n * - Unique destination tracking per day\n * - Optional cooldown after high-value transactions\n * - State persistence across restarts (optional)\n */\nexport class LimitTracker {\n  private state: LimitState;\n  private readonly config: LimitConfig;\n  private readonly persistencePath: string | undefined;\n  private readonly clock: () => Date;\n  private resetInterval: ReturnType<typeof setInterval> | undefined;\n\n  constructor(options: LimitTrackerOptions) {\n    this.config = options.config;\n    this.persistencePath = options.persistencePath;\n    this.clock = options.clock ?? (() => new Date());\n\n    // Initialize fresh state\n    this.state = this.createFreshState();\n\n    // Schedule periodic reset checks (every minute)\n    this.schedulePeriodicCheck();\n  }\n\n  /**\n   * Create fresh limit state.\n   */\n  private createFreshState(): LimitState {\n    const now = this.clock();\n    return {\n      daily: {\n        date: this.getDateString(now),\n        transactionCount: 0,\n        totalVolumeXrp: 0,\n        uniqueDestinations: new Set(),\n        lastTransactionTime: null,\n      },\n      hourly: {\n        transactions: [],\n      },\n      cooldown: {\n        active: false,\n        reason: null,\n        expiresAt: null,\n        triggeredBy: null,\n      },\n    };\n  }\n\n  /**\n   * Check if a transaction would exceed any limits.\n   * Does NOT record the transaction - call recordTransaction after successful signing.\n   */\n  checkLimits(context: PolicyContext): LimitCheckResult {\n    const now = this.clock();\n\n    // Ensure state is current\n    this.maybeResetDaily(now);\n    this.pruneHourlyWindow(now);\n\n    // Check cooldown\n    if (this.state.cooldown.active) {\n      if (this.state.cooldown.expiresAt && now < this.state.cooldown.expiresAt) {\n        return {\n          exceeded: true,\n          reason: `Cooldown active: ${this.state.cooldown.reason}`,\n          limitType: 'cooldown',\n          currentValue: 0,\n          limitValue: 0,\n          expiresAt: this.state.cooldown.expiresAt,\n        };\n      } else {\n        this.clearCooldown();\n      }\n    }\n\n    // Check per-transaction amount limit\n    const txAmountXrp = context.transaction.amount_xrp ?? 0;\n    if (\n      this.config.maxAmountPerTxXrp !== undefined &&\n      txAmountXrp > this.config.maxAmountPerTxXrp\n    ) {\n      return {\n        exceeded: true,\n        reason: `Transaction amount ${txAmountXrp} XRP exceeds per-tx limit of ${this.config.maxAmountPerTxXrp} XRP`,\n        limitType: 'per_tx_amount',\n        currentValue: txAmountXrp,\n        limitValue: this.config.maxAmountPerTxXrp,\n      };\n    }\n\n    // Check daily transaction count\n    if (this.state.daily.transactionCount >= this.config.maxTransactionsPerDay) {\n      return {\n        exceeded: true,\n        reason: `Daily transaction count limit (${this.config.maxTransactionsPerDay}) exceeded`,\n        limitType: 'daily_count',\n        currentValue: this.state.daily.transactionCount,\n        limitValue: this.config.maxTransactionsPerDay,\n      };\n    }\n\n    // Check hourly transaction count\n    const hourlyCount = this.state.hourly.transactions.length;\n    if (hourlyCount >= this.config.maxTransactionsPerHour) {\n      return {\n        exceeded: true,\n        reason: `Hourly transaction count limit (${this.config.maxTransactionsPerHour}) exceeded`,\n        limitType: 'hourly_count',\n        currentValue: hourlyCount,\n        limitValue: this.config.maxTransactionsPerHour,\n      };\n    }\n\n    // Check daily volume\n    const projectedVolume = this.state.daily.totalVolumeXrp + txAmountXrp;\n    if (projectedVolume > this.config.maxTotalVolumeXrpPerDay) {\n      return {\n        exceeded: true,\n        reason: `Daily XRP volume limit (${this.config.maxTotalVolumeXrpPerDay} XRP) would be exceeded`,\n        limitType: 'daily_volume',\n        currentValue: this.state.daily.totalVolumeXrp,\n        limitValue: this.config.maxTotalVolumeXrpPerDay,\n        requestedAmount: txAmountXrp,\n      };\n    }\n\n    // Check unique destinations limit\n    const destination = context.transaction.destination;\n    if (\n      this.config.maxUniqueDestinationsPerDay !== undefined &&\n      destination &&\n      !this.state.daily.uniqueDestinations.has(destination) &&\n      this.state.daily.uniqueDestinations.size >= this.config.maxUniqueDestinationsPerDay\n    ) {\n      return {\n        exceeded: true,\n        reason: `Daily unique destination limit (${this.config.maxUniqueDestinationsPerDay}) exceeded`,\n        limitType: 'unique_destinations',\n        currentValue: this.state.daily.uniqueDestinations.size,\n        limitValue: this.config.maxUniqueDestinationsPerDay,\n      };\n    }\n\n    return { exceeded: false };\n  }\n\n  /**\n   * Record a successfully signed transaction.\n   * Call this AFTER signing succeeds, not before.\n   */\n  recordTransaction(context: PolicyContext): void {\n    const now = this.clock();\n\n    // Ensure state is current\n    this.maybeResetDaily(now);\n    this.pruneHourlyWindow(now);\n\n    const txAmountXrp = context.transaction.amount_xrp ?? 0;\n    const destination = context.transaction.destination;\n\n    // Update daily stats\n    this.state.daily.transactionCount++;\n    this.state.daily.totalVolumeXrp += txAmountXrp;\n    this.state.daily.lastTransactionTime = now;\n    if (destination) {\n      this.state.daily.uniqueDestinations.add(destination);\n    }\n\n    // Update hourly window\n    this.state.hourly.transactions.push({\n      timestamp: now,\n      amountXrp: txAmountXrp,\n      destination: destination ?? '',\n    });\n\n    // Check if cooldown should be triggered\n    const cooldownConfig = this.config.cooldownAfterHighValue;\n    if (\n      cooldownConfig?.enabled &&\n      txAmountXrp >= cooldownConfig.thresholdXrp\n    ) {\n      this.activateCooldown(\n        `High-value transaction (${txAmountXrp} XRP)`,\n        cooldownConfig.cooldownSeconds,\n        context.transaction.type\n      );\n    }\n  }\n\n  /**\n   * Check if daily reset should happen.\n   */\n  private maybeResetDaily(now: Date): void {\n    const currentDate = this.getDateString(now);\n    const currentHour = now.getUTCHours();\n\n    // Check if we've crossed the reset boundary\n    const shouldReset =\n      this.state.daily.date !== currentDate ||\n      (this.state.daily.date === currentDate &&\n        currentHour >= this.config.dailyResetHour &&\n        this.state.daily.lastTransactionTime &&\n        this.state.daily.lastTransactionTime.getUTCHours() < this.config.dailyResetHour);\n\n    if (shouldReset) {\n      this.state.daily = {\n        date: currentDate,\n        transactionCount: 0,\n        totalVolumeXrp: 0,\n        uniqueDestinations: new Set(),\n        lastTransactionTime: null,\n      };\n    }\n  }\n\n  /**\n   * Remove transactions older than 1 hour from sliding window.\n   */\n  private pruneHourlyWindow(now: Date): void {\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n\n    this.state.hourly.transactions = this.state.hourly.transactions.filter(\n      (tx) => tx.timestamp > oneHourAgo\n    );\n  }\n\n  /**\n   * Activate cooldown period.\n   */\n  private activateCooldown(\n    reason: string,\n    durationSeconds: number,\n    triggeredBy: string\n  ): void {\n    const now = this.clock();\n    this.state.cooldown = {\n      active: true,\n      reason,\n      expiresAt: new Date(now.getTime() + durationSeconds * 1000),\n      triggeredBy,\n    };\n  }\n\n  /**\n   * Clear active cooldown.\n   */\n  private clearCooldown(): void {\n    this.state.cooldown = {\n      active: false,\n      reason: null,\n      expiresAt: null,\n      triggeredBy: null,\n    };\n  }\n\n  /**\n   * Schedule periodic check for daily reset.\n   */\n  private schedulePeriodicCheck(): void {\n    // Check every minute\n    this.resetInterval = setInterval(() => {\n      this.maybeResetDaily(this.clock());\n    }, 60 * 1000);\n  }\n\n  /**\n   * Stop periodic checks (for cleanup).\n   */\n  dispose(): void {\n    if (this.resetInterval) {\n      clearInterval(this.resetInterval);\n      this.resetInterval = undefined;\n    }\n  }\n\n  // ============================================================================\n  // GETTERS FOR RULE EVALUATION\n  // ============================================================================\n\n  /**\n   * Get current daily XRP volume.\n   */\n  getDailyVolumeXrp(): number {\n    this.maybeResetDaily(this.clock());\n    return this.state.daily.totalVolumeXrp;\n  }\n\n  /**\n   * Get transactions in the last hour.\n   */\n  getHourlyCount(): number {\n    const now = this.clock();\n    this.pruneHourlyWindow(now);\n    return this.state.hourly.transactions.length;\n  }\n\n  /**\n   * Get daily transaction count.\n   */\n  getDailyCount(): number {\n    this.maybeResetDaily(this.clock());\n    return this.state.daily.transactionCount;\n  }\n\n  /**\n   * Get unique destination count for today.\n   */\n  getUniqueDestinationCount(): number {\n    this.maybeResetDaily(this.clock());\n    return this.state.daily.uniqueDestinations.size;\n  }\n\n  /**\n   * Check if a destination has been used before today.\n   */\n  isDestinationKnown(destination: string): boolean {\n    this.maybeResetDaily(this.clock());\n    return this.state.daily.uniqueDestinations.has(destination);\n  }\n\n  /**\n   * Get complete limit state (copy for safety).\n   */\n  getState(): LimitState {\n    const now = this.clock();\n    this.maybeResetDaily(now);\n    this.pruneHourlyWindow(now);\n\n    return {\n      daily: {\n        ...this.state.daily,\n        uniqueDestinations: new Set(this.state.daily.uniqueDestinations),\n      },\n      hourly: {\n        transactions: [...this.state.hourly.transactions],\n      },\n      cooldown: { ...this.state.cooldown },\n    };\n  }\n\n  /**\n   * Get remaining limits for current period.\n   */\n  getRemainingLimits(): {\n    dailyTxRemaining: number;\n    hourlyTxRemaining: number;\n    dailyVolumeRemainingXrp: number;\n    uniqueDestinationsRemaining: number;\n  } {\n    const now = this.clock();\n    this.maybeResetDaily(now);\n    this.pruneHourlyWindow(now);\n\n    return {\n      dailyTxRemaining: Math.max(\n        0,\n        this.config.maxTransactionsPerDay - this.state.daily.transactionCount\n      ),\n      hourlyTxRemaining: Math.max(\n        0,\n        this.config.maxTransactionsPerHour - this.state.hourly.transactions.length\n      ),\n      dailyVolumeRemainingXrp: Math.max(\n        0,\n        this.config.maxTotalVolumeXrpPerDay - this.state.daily.totalVolumeXrp\n      ),\n      uniqueDestinationsRemaining: Math.max(\n        0,\n        (this.config.maxUniqueDestinationsPerDay ?? Infinity) -\n          this.state.daily.uniqueDestinations.size\n      ),\n    };\n  }\n\n  /**\n   * Reset all limits. Requires confirmation string for safety.\n   */\n  reset(confirmation: string): void {\n    if (confirmation !== 'CONFIRM_LIMIT_RESET') {\n      throw new Error('Invalid confirmation string for limit reset');\n    }\n    this.state = this.createFreshState();\n  }\n\n  /**\n   * Get date string in YYYY-MM-DD format.\n   */\n  private getDateString(date: Date): string {\n    // ISO date format is always YYYY-MM-DDTHH:mm:ss.sssZ, so split always produces [date, time]\n    return date.toISOString().split('T')[0]!;\n  }\n}\n\n// ============================================================================\n// FACTORY FUNCTION\n// ============================================================================\n\n/**\n * Create a LimitTracker from policy limits configuration.\n */\nexport function createLimitTracker(\n  limits: {\n    max_tx_per_hour: number;\n    max_tx_per_day: number;\n    max_daily_volume_drops: string;\n    max_amount_per_tx_drops: string;\n  },\n  options?: {\n    dailyResetHour?: number | undefined;\n    maxUniqueDestinationsPerDay?: number | undefined;\n    cooldownAfterHighValue?: {\n      enabled: boolean;\n      thresholdXrp: number;\n      cooldownSeconds: number;\n    } | undefined;\n    clock?: (() => Date) | undefined;\n  }\n): LimitTracker {\n  // Convert drops to XRP\n  const dropsToXrp = (drops: string): number => {\n    return Number(BigInt(drops)) / 1_000_000;\n  };\n\n  const config: LimitConfig = {\n    dailyResetHour: options?.dailyResetHour ?? 0,\n    maxTransactionsPerHour: limits.max_tx_per_hour,\n    maxTransactionsPerDay: limits.max_tx_per_day,\n    maxTotalVolumeXrpPerDay: dropsToXrp(limits.max_daily_volume_drops),\n    maxAmountPerTxXrp: dropsToXrp(limits.max_amount_per_tx_drops),\n    maxUniqueDestinationsPerDay: options?.maxUniqueDestinationsPerDay,\n    cooldownAfterHighValue: options?.cooldownAfterHighValue,\n  };\n\n  const trackerOptions: LimitTrackerOptions = {\n    config,\n  };\n  if (options?.clock) {\n    trackerOptions.clock = options.clock;\n  }\n\n  return new LimitTracker(trackerOptions);\n}\n","/**\n * Policy Engine Implementation\n *\n * The core policy engine that evaluates transactions against declarative\n * policies before allowing signing operations. Implements an OPA-inspired\n * rule evaluation system entirely in TypeScript.\n *\n * @module policy/engine\n * @version 1.0.0\n */\n\nimport { createHash } from 'crypto';\nimport type {\n  PolicyContext,\n  PolicyResult,\n  PolicyInfo,\n  InternalPolicy,\n  PolicyEngineOptions,\n  Tier,\n  TierFactor,\n  LimitState,\n  PolicyRule,\n} from './types.js';\nimport {\n  PolicyError,\n  PolicyLoadError,\n  PolicyValidationError,\n  PolicyEvaluationError,\n  tierToNumeric,\n} from './types.js';\nimport { RuleEvaluator, checkBlocklist, isInAllowlist, type RuleEvaluatorOptions } from './evaluator.js';\nimport { LimitTracker, type LimitTrackerOptions } from './limits.js';\nimport type { AgentWalletPolicy, ApprovalTier } from '../schemas/index.js';\n\n// ============================================================================\n// POLICY ENGINE INTERFACE\n// ============================================================================\n\n/**\n * Core policy engine interface.\n * All evaluation methods are synchronous and deterministic.\n */\nexport interface IPolicyEngine {\n  /**\n   * Evaluate a transaction against the loaded policy.\n   * This is the primary entry point for all transaction authorization.\n   */\n  evaluate(context: PolicyContext): PolicyResult;\n\n  /**\n   * Get the SHA-256 hash of the currently loaded policy.\n   * Used for integrity verification and audit logging.\n   */\n  getPolicyHash(): string;\n\n  /**\n   * Get policy metadata without exposing internal rules.\n   */\n  getPolicyInfo(): PolicyInfo;\n\n  /**\n   * Verify policy integrity against stored hash.\n   * Should be called periodically and before signing operations.\n   */\n  verifyIntegrity(): boolean;\n\n  /**\n   * Get current limit state for monitoring/debugging.\n   * Does not expose sensitive policy details.\n   */\n  getLimitState(): LimitState;\n\n  /**\n   * Reset limit counters. Only for testing or administrative override.\n   * Requires explicit confirmation and is logged.\n   */\n  resetLimits(confirmation: string): void;\n\n  /**\n   * Record a successful transaction for limit tracking.\n   */\n  recordTransaction(context: PolicyContext): void;\n\n  /**\n   * Clean up resources (intervals, etc).\n   */\n  dispose(): void;\n}\n\n// ============================================================================\n// POLICY ENGINE IMPLEMENTATION\n// ============================================================================\n\n/**\n * Policy Engine - Security boundary for transaction authorization.\n *\n * Features:\n * - Immutable policy after loading\n * - Priority-based rule evaluation\n * - 4-tier classification (autonomous, delayed, co-sign, prohibited)\n * - Blocklist/allowlist support\n * - Memo pattern detection for prompt injection\n * - Rate and volume limiting\n * - Policy integrity verification\n *\n * Security Guarantees:\n * - LLM/agent cannot modify policies at runtime\n * - Policy integrity verified on each evaluation\n * - Fail-secure: any error results in denial\n * - Hard limits enforce absolute ceilings\n */\nexport class PolicyEngine implements IPolicyEngine {\n  /** Frozen policy data */\n  private readonly policy: Readonly<InternalPolicy>;\n  /** SHA-256 hash of serialized policy */\n  private readonly policyHash: string;\n  /** When policy was loaded */\n  private readonly loadedAt: Date;\n  /** Rule evaluator */\n  private readonly ruleEvaluator: RuleEvaluator;\n  /** Limit tracker */\n  private readonly limitTracker: LimitTracker;\n  /** Custom clock for testing */\n  private readonly clock: () => Date;\n  /** Regex cache for blocklist patterns */\n  private readonly regexCache: Map<string, RegExp> = new Map();\n\n  constructor(policy: InternalPolicy, options?: PolicyEngineOptions) {\n    this.clock = options?.clock ?? (() => new Date());\n    this.loadedAt = this.clock();\n\n    // Compute hash before freezing\n    this.policyHash = this.computeHash(policy);\n\n    // Deep freeze the policy to prevent modifications\n    this.policy = this.deepFreeze(policy);\n\n    // Initialize rule evaluator\n    const evaluatorOptions: RuleEvaluatorOptions = {};\n    if (options?.regexTimeoutMs !== undefined) {\n      evaluatorOptions.regexTimeoutMs = options.regexTimeoutMs;\n    }\n    this.ruleEvaluator = new RuleEvaluator(evaluatorOptions);\n\n    // Compile rules\n    this.ruleEvaluator.compileRules(this.policy.rules);\n\n    // Initialize limit tracker\n    const limitTrackerOptions: LimitTrackerOptions = {\n      config: {\n        dailyResetHour: this.policy.limits.daily_reset_utc_hour ?? 0,\n        maxTransactionsPerHour: this.policy.limits.max_transactions_per_hour,\n        maxTransactionsPerDay: this.policy.limits.max_transactions_per_day,\n        maxTotalVolumeXrpPerDay: this.policy.limits.max_total_volume_xrp_per_day,\n        maxUniqueDestinationsPerDay:\n          this.policy.limits.max_unique_destinations_per_day,\n        cooldownAfterHighValue: this.policy.limits.cooldown_after_high_value\n          ? {\n              enabled: this.policy.limits.cooldown_after_high_value.enabled,\n              thresholdXrp:\n                this.policy.limits.cooldown_after_high_value.threshold_xrp,\n              cooldownSeconds:\n                this.policy.limits.cooldown_after_high_value.cooldown_seconds,\n            }\n          : undefined,\n      },\n      clock: this.clock,\n    };\n    this.limitTracker = new LimitTracker(limitTrackerOptions);\n  }\n\n  /**\n   * Evaluate a transaction against the loaded policy.\n   */\n  evaluate(context: PolicyContext): PolicyResult {\n    const startTime = performance.now();\n\n    try {\n      // Step 1: Verify policy integrity\n      if (!this.verifyIntegrity()) {\n        return this.createProhibitedResult(\n          'Policy integrity check failed',\n          'integrity-check',\n          startTime\n        );\n      }\n\n      // Step 2: Check if policy is enabled\n      if (this.policy.enabled === false) {\n        return this.createProhibitedResult(\n          'Policy is disabled',\n          'policy-disabled',\n          startTime\n        );\n      }\n\n      // Step 3: Check global limits first (hard ceiling)\n      const limitResult = this.checkGlobalLimits(context);\n      if (limitResult) {\n        return {\n          ...limitResult,\n          evaluationTimeMs: performance.now() - startTime,\n        };\n      }\n\n      // Step 4: Check blocklist (highest priority)\n      const blocklistResult = checkBlocklist(context, this.policy, this.regexCache);\n      if (blocklistResult.blocked) {\n        return this.createProhibitedResult(\n          blocklistResult.reason!,\n          blocklistResult.matchedRule!,\n          startTime,\n          blocklistResult.injectionDetected\n        );\n      }\n\n      // Step 5: Check transaction type restrictions\n      const typeResult = this.checkTransactionType(context);\n      if (typeResult) {\n        return {\n          ...typeResult,\n          evaluationTimeMs: performance.now() - startTime,\n        };\n      }\n\n      // Step 6: Evaluate rules in priority order\n      const ruleResult = this.ruleEvaluator.evaluate(context, this.policy);\n\n      // Step 7: Apply tier-specific constraints and amount escalation\n      const finalResult = this.applyTierConstraints(ruleResult, context);\n\n      return {\n        ...finalResult,\n        evaluationTimeMs: performance.now() - startTime,\n      };\n    } catch (error) {\n      // Log error with full details\n      console.error('Policy evaluation error:', {\n        correlationId: context.correlationId,\n        error,\n        transactionType: context.transaction.type,\n      });\n\n      // Fail-secure: return prohibited on any error\n      if (error instanceof PolicyError) {\n        return this.createProhibitedResult(\n          `Policy error: ${error.code}`,\n          'error-handler',\n          startTime\n        );\n      }\n\n      return this.createProhibitedResult(\n        'Internal policy engine error',\n        'error-handler',\n        startTime\n      );\n    }\n  }\n\n  /**\n   * Check global limits.\n   */\n  private checkGlobalLimits(context: PolicyContext): PolicyResult | null {\n    const limitCheck = this.limitTracker.checkLimits(context);\n\n    if (limitCheck.exceeded) {\n      return {\n        allowed: false,\n        tier: 'prohibited',\n        tierNumeric: 4,\n        reason: limitCheck.reason!,\n        matchedRule: `limit-${limitCheck.limitType}`,\n        factors: [\n          {\n            source: 'limit_exceeded',\n            tier: 'prohibited',\n            reason: limitCheck.reason!,\n          },\n        ],\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Check transaction type restrictions.\n   */\n  private checkTransactionType(context: PolicyContext): PolicyResult | null {\n    const txType = context.transaction.type;\n\n    // Check prohibited transaction types\n    const prohibitedTypes =\n      this.policy.tiers.prohibited?.prohibited_transaction_types ?? [];\n    if (prohibitedTypes.includes(txType)) {\n      return {\n        allowed: false,\n        tier: 'prohibited',\n        tierNumeric: 4,\n        reason: `Transaction type ${txType} is prohibited`,\n        matchedRule: 'prohibited-type',\n        factors: [\n          {\n            source: 'prohibited_type',\n            tier: 'prohibited',\n            reason: `Transaction type ${txType} is prohibited`,\n          },\n        ],\n      };\n    }\n\n    // Check per-type configuration\n    const typeConfig = this.policy.transaction_types?.[txType];\n    if (typeConfig?.enabled === false) {\n      return {\n        allowed: false,\n        tier: 'prohibited',\n        tierNumeric: 4,\n        reason: `Transaction type ${txType} is disabled`,\n        matchedRule: 'type-disabled',\n        factors: [\n          {\n            source: 'transaction_type',\n            tier: 'prohibited',\n            reason: `Transaction type ${txType} is disabled`,\n          },\n        ],\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Apply tier-specific constraints and amount escalation.\n   */\n  private applyTierConstraints(\n    ruleResult: {\n      matched: boolean;\n      ruleId: string;\n      ruleName: string;\n      tier: Tier;\n      reason: string;\n      overrideDelaySeconds?: number | undefined;\n      notify?: boolean | undefined;\n    },\n    context: PolicyContext\n  ): PolicyResult {\n    let tier: Tier = ruleResult.tier;\n    const factors: TierFactor[] = [\n      {\n        source: 'rule',\n        tier: ruleResult.tier,\n        reason: ruleResult.reason,\n      },\n    ];\n\n    // Check per-type configuration for require_cosign\n    const typeConfig = this.policy.transaction_types?.[context.transaction.type];\n    if (typeConfig?.require_cosign && tier !== 'prohibited') {\n      tier = this.compareTiers('cosign', tier);\n      if (tier === 'cosign') {\n        factors.push({\n          source: 'transaction_type',\n          tier: 'cosign',\n          reason: `Type ${context.transaction.type} requires co-sign`,\n        });\n      }\n    }\n\n    // Apply amount-based tier escalation\n    tier = this.applyAmountEscalation(tier, context, factors);\n\n    // Check new destination escalation\n    tier = this.applyNewDestinationEscalation(tier, context, factors);\n\n    // Build final result\n    const result: PolicyResult = {\n      allowed: tier !== 'prohibited',\n      tier,\n      tierNumeric: tierToNumeric(tier),\n      reason: factors.find((f) => f.tier === tier)?.reason ?? ruleResult.reason,\n      matchedRule: ruleResult.ruleId,\n      factors,\n    };\n\n    // Add tier-specific details\n    switch (tier) {\n      case 'delayed':\n        result.delaySeconds =\n          ruleResult.overrideDelaySeconds ??\n          this.policy.tiers.delayed?.delay_seconds ??\n          300;\n        result.vetoEnabled = this.policy.tiers.delayed?.veto_enabled ?? true;\n        result.notify =\n          ruleResult.notify ?? this.policy.tiers.delayed?.notify_on_queue ?? true;\n        break;\n\n      case 'cosign':\n        result.signerQuorum = this.policy.tiers.cosign?.signer_quorum ?? 2;\n        result.approvalTimeoutHours =\n          this.policy.tiers.cosign?.approval_timeout_hours ?? 24;\n        result.signerAddresses = this.policy.tiers.cosign?.signer_addresses ?? [];\n        result.notify = ruleResult.notify ?? true;\n        break;\n\n      case 'autonomous':\n        result.notify = ruleResult.notify ?? false;\n        break;\n    }\n\n    return result;\n  }\n\n  /**\n   * Apply amount-based tier escalation.\n   */\n  private applyAmountEscalation(\n    currentTier: Tier,\n    context: PolicyContext,\n    factors: TierFactor[]\n  ): Tier {\n    const amountXrp = context.transaction.amount_xrp ?? 0;\n    const tiers = this.policy.tiers;\n\n    // Check if amount exceeds delayed tier max -> escalate to cosign\n    if (\n      tiers.delayed?.max_amount_xrp !== undefined &&\n      amountXrp > tiers.delayed.max_amount_xrp\n    ) {\n      if (currentTier === 'autonomous' || currentTier === 'delayed') {\n        factors.push({\n          source: 'amount_limit',\n          tier: 'cosign',\n          reason: `Amount ${amountXrp} XRP exceeds delayed tier max (${tiers.delayed.max_amount_xrp})`,\n        });\n        return 'cosign';\n      }\n    }\n\n    // Check if amount exceeds autonomous tier max -> escalate to delayed\n    if (\n      tiers.autonomous?.max_amount_xrp !== undefined &&\n      amountXrp > tiers.autonomous.max_amount_xrp\n    ) {\n      if (currentTier === 'autonomous') {\n        // Check if within delayed range\n        if (\n          tiers.delayed?.max_amount_xrp === undefined ||\n          amountXrp <= tiers.delayed.max_amount_xrp\n        ) {\n          factors.push({\n            source: 'amount_limit',\n            tier: 'delayed',\n            reason: `Amount ${amountXrp} XRP exceeds autonomous tier max (${tiers.autonomous.max_amount_xrp})`,\n          });\n          return 'delayed';\n        }\n      }\n    }\n\n    // Check per-type amount limits\n    const typeConfig = this.policy.transaction_types?.[context.transaction.type];\n    if (typeConfig?.max_amount_xrp !== undefined && amountXrp > typeConfig.max_amount_xrp) {\n      if (currentTier === 'autonomous') {\n        factors.push({\n          source: 'amount_limit',\n          tier: 'delayed',\n          reason: `Amount ${amountXrp} XRP exceeds ${context.transaction.type} limit (${typeConfig.max_amount_xrp})`,\n        });\n        return 'delayed';\n      }\n    }\n\n    return currentTier;\n  }\n\n  /**\n   * Apply new destination escalation.\n   */\n  private applyNewDestinationEscalation(\n    currentTier: Tier,\n    context: PolicyContext,\n    factors: TierFactor[]\n  ): Tier {\n    // Skip if no destination or already prohibited\n    if (!context.transaction.destination || currentTier === 'prohibited') {\n      return currentTier;\n    }\n\n    // Check if destination is in allowlist\n    if (isInAllowlist(context, this.policy)) {\n      return currentTier;\n    }\n\n    let resultTier = currentTier;\n\n    // Check if autonomous tier requires known destination\n    if (\n      resultTier === 'autonomous' &&\n      this.policy.tiers.autonomous?.require_known_destination\n    ) {\n      factors.push({\n        source: 'new_destination',\n        tier: 'delayed',\n        reason: 'Destination not in allowlist (require_known_destination enabled)',\n      });\n      resultTier = 'delayed';\n    }\n\n    // Check if cosign always required for new destinations\n    // This can further escalate from autonomous or delayed to cosign\n    if (this.policy.tiers.cosign?.new_destination_always) {\n      // Check if destination is known from today's transactions\n      const isKnown = this.limitTracker.isDestinationKnown(\n        context.transaction.destination\n      );\n\n      if (!isKnown) {\n        const newTier = this.compareTiers('cosign', resultTier);\n        if (newTier === 'cosign' && resultTier !== 'cosign') {\n          factors.push({\n            source: 'new_destination',\n            tier: 'cosign',\n            reason: 'First transaction to new destination',\n          });\n          resultTier = 'cosign';\n        }\n      }\n    }\n\n    return resultTier;\n  }\n\n  /**\n   * Compare two tiers and return the more restrictive one.\n   */\n  private compareTiers(tier1: Tier, tier2: Tier): Tier {\n    const tierOrder: Record<Tier, number> = {\n      autonomous: 1,\n      delayed: 2,\n      cosign: 3,\n      prohibited: 4,\n    };\n\n    return tierOrder[tier1] > tierOrder[tier2] ? tier1 : tier2;\n  }\n\n  /**\n   * Create a prohibited result.\n   */\n  private createProhibitedResult(\n    reason: string,\n    matchedRule: string,\n    startTime: number,\n    injectionDetected?: boolean\n  ): PolicyResult {\n    const result: PolicyResult = {\n      allowed: false,\n      tier: 'prohibited',\n      tierNumeric: 4,\n      reason,\n      matchedRule,\n      evaluationTimeMs: performance.now() - startTime,\n    };\n    if (injectionDetected !== undefined) {\n      result.injectionDetected = injectionDetected;\n    }\n    return result;\n  }\n\n  // ============================================================================\n  // PUBLIC METHODS\n  // ============================================================================\n\n  /**\n   * Get policy hash.\n   */\n  getPolicyHash(): string {\n    return this.policyHash;\n  }\n\n  /**\n   * Get policy info.\n   */\n  getPolicyInfo(): PolicyInfo {\n    const info: PolicyInfo = {\n      name: this.policy.name,\n      version: this.policy.version,\n      network: this.policy.network,\n      enabled: this.policy.enabled,\n      loadedAt: this.loadedAt,\n      hash: this.policyHash.slice(0, 16),\n      ruleCount: this.policy.rules.length,\n      enabledRuleCount: this.ruleEvaluator.getRuleCount(),\n    };\n    if (this.policy.description !== undefined) {\n      info.description = this.policy.description;\n    }\n    return info;\n  }\n\n  /**\n   * Verify policy integrity.\n   */\n  verifyIntegrity(): boolean {\n    const currentHash = this.computeHash(this.policy);\n    return currentHash === this.policyHash;\n  }\n\n  /**\n   * Get limit state.\n   */\n  getLimitState(): LimitState {\n    return this.limitTracker.getState();\n  }\n\n  /**\n   * Reset limits.\n   */\n  resetLimits(confirmation: string): void {\n    this.limitTracker.reset(confirmation);\n  }\n\n  /**\n   * Record a successful transaction.\n   */\n  recordTransaction(context: PolicyContext): void {\n    this.limitTracker.recordTransaction(context);\n  }\n\n  /**\n   * Dispose of resources.\n   */\n  dispose(): void {\n    this.limitTracker.dispose();\n  }\n\n  // ============================================================================\n  // PRIVATE HELPERS\n  // ============================================================================\n\n  /**\n   * Compute SHA-256 hash of policy.\n   */\n  private computeHash(policy: InternalPolicy | Readonly<InternalPolicy>): string {\n    const content = JSON.stringify(policy);\n    return createHash('sha256').update(content).digest('hex');\n  }\n\n  /**\n   * Deep freeze an object.\n   */\n  private deepFreeze<T extends object>(obj: T): Readonly<T> {\n    const propNames = Object.getOwnPropertyNames(obj);\n\n    for (const name of propNames) {\n      const value = (obj as Record<string, unknown>)[name];\n      if (value && typeof value === 'object') {\n        this.deepFreeze(value as object);\n      }\n    }\n\n    return Object.freeze(obj);\n  }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS\n// ============================================================================\n\n/**\n * Create a PolicyEngine from an AgentWalletPolicy.\n */\nexport function createPolicyEngine(\n  policy: AgentWalletPolicy,\n  options?: PolicyEngineOptions\n): PolicyEngine {\n  // Convert AgentWalletPolicy to InternalPolicy format\n  const internalPolicy: InternalPolicy = {\n    version: policy.policy_version,\n    name: policy.policy_id,\n    network: 'mainnet', // Default, should be provided externally\n    enabled: true,\n    tiers: {\n      autonomous: {\n        max_amount_xrp: dropsToXrp(policy.limits.max_amount_per_tx_drops),\n        daily_limit_xrp: dropsToXrp(policy.limits.max_daily_volume_drops),\n        require_known_destination:\n          policy.destinations.mode === 'allowlist' ||\n          !policy.destinations.allow_new_destinations,\n        allowed_transaction_types: policy.transaction_types.allowed,\n      },\n      delayed: {\n        max_amount_xrp: dropsToXrp(policy.escalation.amount_threshold_drops),\n        delay_seconds: policy.escalation.delay_seconds ?? 300,\n        veto_enabled: true,\n        notify_on_queue: true,\n      },\n      cosign: {\n        signer_quorum: 2,\n        new_destination_always: policy.escalation.new_destination === 3,\n        approval_timeout_hours: 24,\n      },\n      prohibited: {\n        prohibited_transaction_types: policy.transaction_types.blocked ?? [],\n      },\n    },\n    rules: buildRulesFromPolicy(policy),\n    blocklist: {\n      addresses: policy.destinations.blocklist ?? [],\n    },\n    allowlist: {\n      addresses:\n        policy.destinations.mode === 'allowlist'\n          ? policy.destinations.allowlist ?? []\n          : [],\n    },\n    limits: {\n      daily_reset_utc_hour: 0,\n      max_transactions_per_hour: policy.limits.max_tx_per_hour,\n      max_transactions_per_day: policy.limits.max_tx_per_day,\n      max_total_volume_xrp_per_day: dropsToXrp(policy.limits.max_daily_volume_drops),\n    },\n  };\n\n  return new PolicyEngine(internalPolicy, options);\n}\n\n/**\n * Convert drops string to XRP number.\n */\nfunction dropsToXrp(drops: string): number {\n  return Number(BigInt(drops)) / 1_000_000;\n}\n\n/**\n * Build rules from AgentWalletPolicy.\n */\nfunction buildRulesFromPolicy(policy: AgentWalletPolicy): PolicyRule[] {\n  const rules: PolicyRule[] = [];\n  let priority = 1;\n\n  // Rule: Check blocklist first\n  if (policy.destinations.blocklist && policy.destinations.blocklist.length > 0) {\n    rules.push({\n      id: 'blocklist-check',\n      name: 'Blocklist Check',\n      priority: priority++,\n      condition: {\n        field: 'destination',\n        operator: 'in',\n        value: { ref: 'blocklist.addresses' },\n      },\n      action: {\n        tier: 'prohibited',\n        reason: 'Destination is blocklisted',\n      },\n    });\n  }\n\n  // Rule: Check blocked transaction types\n  if (policy.transaction_types.blocked && policy.transaction_types.blocked.length > 0) {\n    for (const txType of policy.transaction_types.blocked) {\n      rules.push({\n        id: `block-${txType.toLowerCase()}`,\n        name: `Block ${txType}`,\n        priority: priority++,\n        condition: {\n          field: 'transaction_type',\n          operator: '==',\n          value: txType,\n        },\n        action: {\n          tier: 'prohibited',\n          reason: `Transaction type ${txType} is not allowed`,\n        },\n      });\n    }\n  }\n\n  // Rule: Require approval transaction types\n  if (\n    policy.transaction_types.require_approval &&\n    policy.transaction_types.require_approval.length > 0\n  ) {\n    for (const txType of policy.transaction_types.require_approval) {\n      rules.push({\n        id: `require-approval-${txType.toLowerCase()}`,\n        name: `Require Approval for ${txType}`,\n        priority: priority++,\n        condition: {\n          field: 'transaction_type',\n          operator: '==',\n          value: txType,\n        },\n        action: {\n          tier: 'cosign',\n          reason: `Transaction type ${txType} requires approval`,\n        },\n      });\n    }\n  }\n\n  // Rule: High value transactions\n  const thresholdXrp = dropsToXrp(policy.escalation.amount_threshold_drops);\n  rules.push({\n    id: 'high-value-cosign',\n    name: 'High Value Transaction',\n    priority: priority++,\n    condition: {\n      field: 'amount_xrp',\n      operator: '>=',\n      value: thresholdXrp,\n    },\n    action: {\n      tier: policy.escalation.new_destination === 3 ? 'cosign' : 'delayed',\n      reason: `Amount exceeds ${thresholdXrp} XRP threshold`,\n    },\n  });\n\n  // Rule: New destination handling\n  if (\n    policy.destinations.mode === 'allowlist' ||\n    !policy.destinations.allow_new_destinations\n  ) {\n    rules.push({\n      id: 'new-destination-check',\n      name: 'New Destination Check',\n      priority: priority++,\n      condition: {\n        not: {\n          field: 'destination',\n          operator: 'in',\n          value: { ref: 'allowlist.addresses' },\n        },\n      },\n      action: {\n        tier:\n          policy.destinations.new_destination_tier === 3\n            ? 'cosign'\n            : policy.destinations.new_destination_tier === 2\n              ? 'delayed'\n              : 'prohibited',\n        reason: 'Destination not in allowlist',\n      },\n    });\n  }\n\n  // Rule: Default allow for configured types\n  rules.push({\n    id: 'default-allow',\n    name: 'Default Allow',\n    priority: 999,\n    condition: {\n      always: true,\n    },\n    action: {\n      tier: 'autonomous',\n      reason: 'Transaction within policy limits',\n    },\n  });\n\n  return rules;\n}\n\n/**\n * Create a simple test policy for development.\n */\nexport function createTestPolicy(\n  network: 'mainnet' | 'testnet' | 'devnet' = 'testnet',\n  overrides?: Partial<InternalPolicy>\n): InternalPolicy {\n  const basePolicy: InternalPolicy = {\n    version: '1.0',\n    name: `${network}-test-policy`,\n    description: 'Test policy for development',\n    network,\n    enabled: true,\n    tiers: {\n      autonomous: {\n        max_amount_xrp: network === 'mainnet' ? 100 : 10000,\n        daily_limit_xrp: network === 'mainnet' ? 1000 : 100000,\n        require_known_destination: network === 'mainnet',\n        allowed_transaction_types: ['Payment', 'EscrowFinish', 'EscrowCancel'],\n      },\n      delayed: {\n        max_amount_xrp: network === 'mainnet' ? 1000 : 100000,\n        delay_seconds: network === 'mainnet' ? 300 : 60,\n        veto_enabled: true,\n        notify_on_queue: true,\n      },\n      cosign: {\n        signer_quorum: 2,\n        new_destination_always: network === 'mainnet',\n        approval_timeout_hours: 24,\n      },\n      prohibited: {\n        prohibited_transaction_types: ['Clawback'],\n      },\n    },\n    rules: [\n      {\n        id: 'default-allow',\n        name: 'Default Allow',\n        priority: 999,\n        condition: { always: true },\n        action: { tier: 'autonomous', reason: 'Within policy limits' },\n      },\n    ],\n    blocklist: {\n      addresses: [],\n      memo_patterns: ['ignore.*previous', '\\\\[INST\\\\]', '<<SYS>>'],\n    },\n    allowlist: {\n      addresses: [],\n    },\n    limits: {\n      daily_reset_utc_hour: 0,\n      max_transactions_per_hour: network === 'mainnet' ? 50 : 1000,\n      max_transactions_per_day: network === 'mainnet' ? 200 : 10000,\n      max_unique_destinations_per_day: network === 'mainnet' ? 20 : 500,\n      max_total_volume_xrp_per_day: network === 'mainnet' ? 5000 : 10000000,\n    },\n  };\n\n  // Merge overrides\n  if (overrides) {\n    return deepMerge(basePolicy, overrides) as InternalPolicy;\n  }\n\n  return basePolicy;\n}\n\n/**\n * Deep merge two objects.\n */\nfunction deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  const result = { ...target };\n\n  for (const key of Object.keys(source) as (keyof T)[]) {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n\n    if (\n      sourceValue !== undefined &&\n      typeof sourceValue === 'object' &&\n      sourceValue !== null &&\n      !Array.isArray(sourceValue) &&\n      typeof targetValue === 'object' &&\n      targetValue !== null &&\n      !Array.isArray(targetValue)\n    ) {\n      (result as Record<string, unknown>)[key as string] = deepMerge(\n        targetValue as object,\n        sourceValue as object\n      );\n    } else if (sourceValue !== undefined) {\n      (result as Record<string, unknown>)[key as string] = sourceValue;\n    }\n  }\n\n  return result;\n}\n","/**\n * SecureBuffer - Memory-safe container for sensitive cryptographic data.\n *\n * This class provides controlled access to sensitive data (private keys, seeds)\n * with automatic memory zeroing and serialization prevention.\n *\n * Security Features:\n * - Automatic zeroing of source buffer on creation\n * - Explicit disposal with multiple overwrite passes\n * - Prevention of accidental serialization (JSON, toString)\n * - Clear lifecycle tracking\n *\n * @module keystore/secure-buffer\n * @version 1.0.0\n */\n\n/**\n * SecureBuffer provides memory-safe handling of sensitive data.\n *\n * USAGE:\n * ```typescript\n * const secure = SecureBuffer.from(sensitiveData);\n * try {\n *   // Use secure.getBuffer() for operations\n *   const result = someOperation(secure.getBuffer());\n * } finally {\n *   secure.dispose(); // Always dispose when done\n * }\n * ```\n *\n * SECURITY NOTES:\n * - Source buffer is zeroed when creating from existing data\n * - Buffer contents are overwritten with multiple passes on dispose\n * - Serialization methods throw to prevent accidental exposure\n */\nexport class SecureBuffer {\n  private buffer: Buffer;\n  private isDisposed: boolean = false;\n\n  /**\n   * Private constructor - use static factory methods.\n   */\n  private constructor(size: number) {\n    // Use allocUnsafe for performance since we'll fill it immediately\n    this.buffer = Buffer.allocUnsafe(size);\n  }\n\n  /**\n   * Creates a new SecureBuffer with uninitialized content of specified size.\n   *\n   * @param size - Size in bytes\n   * @returns New SecureBuffer instance\n   */\n  static alloc(size: number): SecureBuffer {\n    if (size <= 0) {\n      throw new Error('SecureBuffer size must be positive');\n    }\n    const secure = new SecureBuffer(size);\n    // Fill with zeros for safety\n    secure.buffer.fill(0);\n    return secure;\n  }\n\n  /**\n   * Creates a SecureBuffer from existing data.\n   *\n   * IMPORTANT: The source buffer is zeroed immediately after copying\n   * to prevent the original data from remaining in memory.\n   *\n   * @param data - Source buffer (will be zeroed)\n   * @returns New SecureBuffer containing the copied data\n   */\n  static from(data: Buffer): SecureBuffer {\n    if (!Buffer.isBuffer(data)) {\n      throw new Error('SecureBuffer.from requires a Buffer');\n    }\n    if (data.length === 0) {\n      throw new Error('SecureBuffer cannot be empty');\n    }\n\n    const secure = new SecureBuffer(data.length);\n    // Copy data to secure buffer\n    data.copy(secure.buffer);\n    // Zero the source buffer immediately\n    data.fill(0);\n    return secure;\n  }\n\n  /**\n   * Gets the buffer contents for use in cryptographic operations.\n   *\n   * @returns The internal Buffer\n   * @throws Error if buffer has been disposed\n   */\n  getBuffer(): Buffer {\n    if (this.isDisposed) {\n      throw new Error('SecureBuffer has been disposed');\n    }\n    return this.buffer;\n  }\n\n  /**\n   * Disposes the buffer by securely zeroing its contents.\n   *\n   * This operation is irreversible. Multiple overwrite passes are used\n   * to help prevent data recovery.\n   */\n  dispose(): void {\n    if (!this.isDisposed) {\n      // Multiple overwrite passes for secure deletion\n      // Pass 1: Zeros\n      this.buffer.fill(0x00);\n      // Pass 2: Ones\n      this.buffer.fill(0xff);\n      // Pass 3: Zeros again\n      this.buffer.fill(0x00);\n\n      this.isDisposed = true;\n    }\n  }\n\n  /**\n   * Alias for dispose() - matches common naming conventions.\n   */\n  zero(): void {\n    this.dispose();\n  }\n\n  /**\n   * Returns whether the buffer has been disposed.\n   */\n  get disposed(): boolean {\n    return this.isDisposed;\n  }\n\n  /**\n   * Alias for disposed getter - matches spec naming.\n   */\n  get zeroed(): boolean {\n    return this.isDisposed;\n  }\n\n  /**\n   * Buffer length in bytes.\n   */\n  get length(): number {\n    return this.buffer.length;\n  }\n\n  /**\n   * Executes an operation with the buffer and ensures cleanup on completion.\n   *\n   * The SecureBuffer is automatically disposed after the operation,\n   * regardless of success or failure.\n   *\n   * @param secure - SecureBuffer to use\n   * @param operation - Async operation that uses the buffer\n   * @returns Result of the operation\n   */\n  static async withSecure<T>(\n    secure: SecureBuffer,\n    operation: (buffer: Buffer) => Promise<T>\n  ): Promise<T> {\n    try {\n      return await operation(secure.getBuffer());\n    } finally {\n      secure.dispose();\n    }\n  }\n\n  /**\n   * Creates a SecureBuffer, executes an operation, and disposes it.\n   *\n   * @param data - Source buffer (will be zeroed)\n   * @param operation - Async operation that uses the buffer\n   * @returns Result of the operation\n   */\n  static async withSecureBuffer<T>(\n    data: Buffer,\n    operation: (buffer: Buffer) => Promise<T>\n  ): Promise<T> {\n    const secure = SecureBuffer.from(data);\n    try {\n      return await operation(secure.getBuffer());\n    } finally {\n      secure.dispose();\n    }\n  }\n\n  // ========================================================================\n  // Serialization Prevention\n  // ========================================================================\n\n  /**\n   * Prevents JSON serialization of sensitive data.\n   * @throws Error always\n   */\n  toJSON(): never {\n    throw new Error('SecureBuffer cannot be serialized to JSON');\n  }\n\n  /**\n   * Returns a placeholder string instead of buffer contents.\n   */\n  toString(): string {\n    return '[SecureBuffer]';\n  }\n\n  /**\n   * Custom Node.js inspection - prevents accidental logging of contents.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\n    return `[SecureBuffer length=${this.length} disposed=${this.isDisposed}]`;\n  }\n\n  /**\n   * Prevents spreading/iteration of buffer contents.\n   */\n  [Symbol.iterator](): never {\n    throw new Error('SecureBuffer cannot be iterated');\n  }\n}\n","/**\n * Keystore Error Types\n *\n * Defines all error types for keystore operations.\n * All errors extend the base KeystoreError class.\n *\n * @module keystore/errors\n * @version 1.0.0\n */\n\nimport type { XRPLNetwork, KeystoreProviderType } from './interface.js';\n\n/**\n * Error codes for keystore operations.\n */\nexport type KeystoreErrorCode =\n  | 'KEYSTORE_INIT_ERROR'\n  | 'WALLET_NOT_FOUND'\n  | 'WALLET_EXISTS'\n  | 'AUTHENTICATION_ERROR'\n  | 'WEAK_PASSWORD'\n  | 'KEY_DECRYPTION_ERROR'\n  | 'KEY_ENCRYPTION_ERROR'\n  | 'INVALID_KEY_FORMAT'\n  | 'KEYSTORE_WRITE_ERROR'\n  | 'KEYSTORE_READ_ERROR'\n  | 'KEYSTORE_CAPACITY_ERROR'\n  | 'BACKUP_FORMAT_ERROR'\n  | 'NETWORK_MISMATCH'\n  | 'PROVIDER_UNAVAILABLE'\n  | 'OPERATION_TIMEOUT'\n  | 'INTERNAL_ERROR';\n\n/**\n * Base error class for all keystore operations.\n *\n * All keystore errors include:\n * - A specific error code for programmatic handling\n * - Whether the error is recoverable\n * - Timestamp of when the error occurred\n * - Optional additional details\n */\nexport abstract class KeystoreError extends Error {\n  /** Error code for programmatic handling */\n  abstract readonly code: KeystoreErrorCode;\n\n  /** Whether this error is recoverable (can be retried) */\n  abstract readonly recoverable: boolean;\n\n  /** Timestamp when error occurred */\n  readonly timestamp: string;\n\n  /** Correlation ID for tracking */\n  readonly correlationId?: string;\n\n  constructor(\n    message: string,\n    public readonly details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.timestamp = new Date().toISOString();\n\n    // Maintain proper stack trace in V8\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  /**\n   * Convert to safe JSON representation (excludes sensitive data).\n   */\n  toSafeJSON(): Record<string, unknown> {\n    return {\n      code: this.code,\n      message: this.message,\n      recoverable: this.recoverable,\n      timestamp: this.timestamp,\n      correlationId: this.correlationId,\n    };\n  }\n}\n\n// ============================================================================\n// Initialization Errors\n// ============================================================================\n\n/**\n * Keystore initialization failed.\n */\nexport class KeystoreInitializationError extends KeystoreError {\n  readonly code = 'KEYSTORE_INIT_ERROR' as const;\n  readonly recoverable = false;\n\n  readonly originalCause: Error | undefined;\n\n  constructor(message: string, originalCause?: Error) {\n    super(message, { cause: originalCause?.message });\n    this.originalCause = originalCause;\n  }\n}\n\n// ============================================================================\n// Wallet Errors\n// ============================================================================\n\n/**\n * Wallet not found in keystore.\n */\nexport class WalletNotFoundError extends KeystoreError {\n  readonly code = 'WALLET_NOT_FOUND' as const;\n  readonly recoverable = false;\n\n  constructor(public readonly walletId: string) {\n    super(`Wallet not found: ${walletId}`, { walletId });\n  }\n}\n\n/**\n * Wallet already exists (duplicate ID or address).\n */\nexport class WalletExistsError extends KeystoreError {\n  readonly code = 'WALLET_EXISTS' as const;\n  readonly recoverable = false;\n\n  constructor(\n    public readonly walletId: string,\n    public readonly existingAddress?: string\n  ) {\n    super(`Wallet already exists: ${walletId}`, { walletId, existingAddress });\n  }\n}\n\n// ============================================================================\n// Authentication Errors\n// ============================================================================\n\n/**\n * Authentication failed (wrong password).\n *\n * Note: Intentionally vague message to prevent enumeration attacks.\n */\nexport class AuthenticationError extends KeystoreError {\n  readonly code = 'AUTHENTICATION_ERROR' as const;\n  readonly recoverable = true;\n\n  constructor() {\n    super('Authentication failed');\n    // No details to prevent password guessing attacks\n  }\n}\n\n/**\n * Password does not meet complexity requirements.\n */\nexport class WeakPasswordError extends KeystoreError {\n  readonly code = 'WEAK_PASSWORD' as const;\n  readonly recoverable = true;\n\n  constructor(public readonly requirements: string[]) {\n    super('Password does not meet security requirements', { requirements });\n  }\n}\n\n// ============================================================================\n// Cryptographic Errors\n// ============================================================================\n\n/**\n * Key decryption failed.\n * Could be wrong password, corrupted data, or algorithm mismatch.\n */\nexport class KeyDecryptionError extends KeystoreError {\n  readonly code = 'KEY_DECRYPTION_ERROR' as const;\n  readonly recoverable = false;\n\n  constructor(message: string = 'Key decryption failed') {\n    super(message);\n  }\n}\n\n/**\n * Key encryption failed during storage.\n */\nexport class KeyEncryptionError extends KeystoreError {\n  readonly code = 'KEY_ENCRYPTION_ERROR' as const;\n  readonly recoverable = false;\n\n  constructor(message: string = 'Key encryption failed') {\n    super(message);\n  }\n}\n\n/**\n * Invalid key format or length.\n */\nexport class InvalidKeyError extends KeystoreError {\n  readonly code = 'INVALID_KEY_FORMAT' as const;\n  readonly recoverable = false;\n\n  constructor(\n    public readonly reason: string,\n    public readonly expectedFormat?: string\n  ) {\n    super(`Invalid key format: ${reason}`, { reason, expectedFormat });\n  }\n}\n\n// ============================================================================\n// Storage Errors\n// ============================================================================\n\n/**\n * Keystore write operation failed.\n */\nexport class KeystoreWriteError extends KeystoreError {\n  readonly code = 'KEYSTORE_WRITE_ERROR' as const;\n  readonly recoverable = true;\n\n  constructor(\n    message: string,\n    public readonly operation: 'create' | 'update' | 'delete'\n  ) {\n    super(message, { operation });\n  }\n}\n\n/**\n * Keystore read operation failed.\n */\nexport class KeystoreReadError extends KeystoreError {\n  readonly code = 'KEYSTORE_READ_ERROR' as const;\n  readonly recoverable = true;\n\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/**\n * Keystore capacity limit reached.\n */\nexport class KeystoreCapacityError extends KeystoreError {\n  readonly code = 'KEYSTORE_CAPACITY_ERROR' as const;\n  readonly recoverable = false;\n\n  constructor(\n    public readonly network: XRPLNetwork,\n    public readonly currentCount: number,\n    public readonly maxCount: number\n  ) {\n    super(`Keystore capacity exceeded for ${network}`, {\n      network,\n      currentCount,\n      maxCount,\n    });\n  }\n}\n\n// ============================================================================\n// Backup Errors\n// ============================================================================\n\n/**\n * Backup format invalid or unsupported.\n */\nexport class BackupFormatError extends KeystoreError {\n  readonly code = 'BACKUP_FORMAT_ERROR' as const;\n  readonly recoverable = false;\n\n  constructor(\n    public readonly reason: string,\n    public readonly expectedVersion?: number\n  ) {\n    super(`Invalid backup format: ${reason}`, { reason, expectedVersion });\n  }\n}\n\n// ============================================================================\n// Network Errors\n// ============================================================================\n\n/**\n * Network mismatch between wallet and operation.\n */\nexport class NetworkMismatchError extends KeystoreError {\n  readonly code = 'NETWORK_MISMATCH' as const;\n  readonly recoverable = false;\n\n  constructor(\n    public readonly walletNetwork: XRPLNetwork,\n    public readonly requestedNetwork: XRPLNetwork\n  ) {\n    super(`Network mismatch: wallet is ${walletNetwork}, requested ${requestedNetwork}`, {\n      walletNetwork,\n      requestedNetwork,\n    });\n  }\n}\n\n/**\n * Provider service unavailable.\n */\nexport class ProviderUnavailableError extends KeystoreError {\n  readonly code = 'PROVIDER_UNAVAILABLE' as const;\n  readonly recoverable = true;\n\n  constructor(\n    public readonly providerType: KeystoreProviderType,\n    public readonly reason: string\n  ) {\n    super(`Provider unavailable: ${reason}`, { providerType, reason });\n  }\n}\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard to check if an error is a KeystoreError.\n */\nexport function isKeystoreError(error: unknown): error is KeystoreError {\n  return error instanceof KeystoreError;\n}\n\n/**\n * Type guard to check if error is a specific keystore error code.\n */\nexport function isKeystoreErrorCode(error: unknown, code: KeystoreErrorCode): boolean {\n  return isKeystoreError(error) && error.code === code;\n}\n","/**\n * Local File Keystore Provider\n *\n * Implements secure local file-based storage for XRPL wallet private keys\n * using AES-256-GCM encryption and Argon2id key derivation.\n *\n * Security Features:\n * - AES-256-GCM encryption for all key material\n * - Argon2id key derivation (64MB memory, 3 iterations, 4 parallelism)\n * - Unique salt per wallet, unique IV per encryption\n * - Atomic file writes (temp + rename)\n * - Strict file permissions (0600)\n * - Network isolation (mainnet/testnet/devnet separated)\n * - Rate limiting for authentication attempts\n *\n * @module keystore/local\n * @version 1.0.0\n */\n\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport * as argon2 from 'argon2';\nimport { Wallet, ECDSA } from 'xrpl';\n\nimport { SecureBuffer } from './secure-buffer.js';\nimport {\n  type KeystoreProvider,\n  type KeystoreConfig,\n  type KeystoreHealthResult,\n  type WalletEntry,\n  type WalletSummary,\n  type WalletPolicy,\n  type WalletCreateOptions,\n  type WalletMetadata,\n  type EncryptedBackup,\n  type ImportOptions,\n  type BackupFormat,\n  type XRPLNetwork,\n  type PasswordPolicy,\n  type KdfParams,\n} from './interface.js';\nimport {\n  KeystoreInitializationError,\n  WalletNotFoundError,\n  WalletExistsError,\n  AuthenticationError,\n  WeakPasswordError,\n  KeyDecryptionError,\n  KeystoreWriteError,\n  KeystoreCapacityError,\n  BackupFormatError,\n  InvalidKeyError,\n} from './errors.js';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Argon2id configuration per ADR-002.\n */\nconst ARGON2_CONFIG = {\n  type: argon2.argon2id,\n  memoryCost: 65536, // 64 MB\n  timeCost: 3, // 3 iterations\n  parallelism: 4, // 4 threads\n  hashLength: 32, // 256-bit output\n  saltLength: 32, // 256-bit salt\n} as const;\n\n/**\n * AES-256-GCM configuration per ADR-001.\n */\nconst AES_CONFIG = {\n  algorithm: 'aes-256-gcm' as const,\n  keyLength: 32, // 256 bits\n  ivLength: 12, // 96 bits (NIST recommended for GCM)\n  authTagLength: 16, // 128 bits\n} as const;\n\n/**\n * File permission constants.\n */\nconst PERMISSIONS = {\n  FILE: 0o600, // Owner read/write only (rw-------)\n  DIRECTORY: 0o700, // Owner read/write/execute only (rwx------)\n} as const;\n\n/**\n * Default password policy.\n */\nconst DEFAULT_PASSWORD_POLICY: PasswordPolicy = {\n  minLength: 12,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecial: false,\n  maxLength: 128,\n};\n\n/**\n * Rate limiting configuration.\n */\nconst RATE_LIMIT_CONFIG = {\n  maxAttempts: 5, // Max failed attempts\n  windowSeconds: 900, // 15 minute window\n  lockoutSeconds: 1800, // 30 minute initial lockout\n  lockoutMultiplier: 2, // Doubles each time\n} as const;\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Wallet file format stored on disk.\n */\ninterface WalletFile {\n  /** File format version */\n  version: 1;\n  /** Unique wallet identifier */\n  walletId: string;\n  /** Wallet metadata and public information */\n  entry: WalletEntry;\n  /** Encrypted private key material */\n  encryptedKey: {\n    /** Base64-encoded encrypted seed/key */\n    data: string;\n    /** Base64-encoded initialization vector (12 bytes) */\n    iv: string;\n    /** Base64-encoded GCM authentication tag (16 bytes) */\n    authTag: string;\n  };\n}\n\n/**\n * Wallet index stored per network.\n */\ninterface WalletIndex {\n  /** Index format version */\n  version: 1;\n  /** List of wallet entries (metadata only, no keys) */\n  wallets: WalletEntry[];\n  /** Last modification timestamp */\n  modifiedAt: string;\n}\n\n/**\n * Authentication attempt record.\n */\ninterface AuthAttemptRecord {\n  timestamp: Date;\n  success: boolean;\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Validates password against policy requirements.\n *\n * @param password - Password to validate\n * @param policy - Password policy to check against\n * @returns Array of error messages (empty if valid)\n */\nfunction validatePassword(password: string, policy: PasswordPolicy): string[] {\n  const errors: string[] = [];\n\n  if (password.length < policy.minLength) {\n    errors.push(`Minimum ${policy.minLength} characters required`);\n  }\n  if (password.length > policy.maxLength) {\n    errors.push(`Maximum ${policy.maxLength} characters allowed`);\n  }\n  if (policy.requireUppercase && !/[A-Z]/.test(password)) {\n    errors.push('Must contain uppercase letter');\n  }\n  if (policy.requireLowercase && !/[a-z]/.test(password)) {\n    errors.push('Must contain lowercase letter');\n  }\n  if (policy.requireNumbers && !/\\d/.test(password)) {\n    errors.push('Must contain number');\n  }\n  if (policy.requireSpecial && !/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n    errors.push('Must contain special character');\n  }\n\n  return errors;\n}\n\n/**\n * Simple file locking mechanism for concurrent access safety.\n */\nclass FileLock {\n  private locks = new Map<string, Promise<void>>();\n\n  /**\n   * Executes operation with exclusive access to the file.\n   */\n  async withLock<T>(key: string, operation: () => Promise<T>): Promise<T> {\n    // Wait for any existing lock\n    while (this.locks.has(key)) {\n      await this.locks.get(key);\n    }\n\n    // Create lock\n    let releaseLock: () => void;\n    const lockPromise = new Promise<void>((resolve) => {\n      releaseLock = resolve;\n    });\n    this.locks.set(key, lockPromise);\n\n    try {\n      return await operation();\n    } finally {\n      this.locks.delete(key);\n      releaseLock!();\n    }\n  }\n}\n\n// ============================================================================\n// LocalKeystore Implementation\n// ============================================================================\n\n/**\n * Local file-based keystore provider implementing the KeystoreProvider interface.\n *\n * Security features:\n * - AES-256-GCM encryption for all key material\n * - Argon2id key derivation (64MB, 3 iterations, 4 parallelism)\n * - Unique salt and IV per encryption operation\n * - Atomic file writes (temp + rename)\n * - Strict file permissions (0600)\n * - SecureBuffer for memory safety\n */\nexport class LocalKeystore implements KeystoreProvider {\n  readonly providerType = 'local-file' as const;\n  readonly providerVersion = '1.0.0';\n\n  private baseDir: string = '';\n  private passwordPolicy: PasswordPolicy = DEFAULT_PASSWORD_POLICY;\n  private maxWalletsPerNetwork: number = 100;\n  private initialized: boolean = false;\n  private fileLock: FileLock = new FileLock();\n\n  // Rate limiting state\n  private authAttempts: Map<string, AuthAttemptRecord[]> = new Map();\n  private lockouts: Map<string, Date> = new Map();\n\n  // ========================================================================\n  // Lifecycle Methods\n  // ========================================================================\n\n  async initialize(config: KeystoreConfig): Promise<void> {\n    if (this.initialized) {\n      throw new KeystoreInitializationError('Provider already initialized');\n    }\n\n    // Resolve base directory\n    const homeDir = process.env['HOME'] || '';\n    this.baseDir = config.baseDir\n      ? path.resolve(config.baseDir.replace(/^~/, homeDir))\n      : path.join(homeDir, '.xrpl-wallet-mcp');\n\n    // Apply configuration\n    if (config.passwordPolicy) {\n      this.passwordPolicy = { ...DEFAULT_PASSWORD_POLICY, ...config.passwordPolicy };\n    }\n    if (config.maxWalletsPerNetwork !== undefined) {\n      this.maxWalletsPerNetwork = config.maxWalletsPerNetwork;\n    }\n\n    // Create directory structure\n    await this.ensureDirectoryStructure();\n\n    // Verify permissions\n    await this.verifyPermissions();\n\n    this.initialized = true;\n  }\n\n  async healthCheck(): Promise<KeystoreHealthResult> {\n    this.assertInitialized();\n\n    const errors: string[] = [];\n    let storageAccessible = true;\n    let encryptionAvailable = true;\n    let networkCount = 0;\n    let walletCount = 0;\n\n    // Check storage access\n    try {\n      await fs.access(this.baseDir, fs.constants.R_OK | fs.constants.W_OK);\n    } catch {\n      storageAccessible = false;\n      errors.push('Base directory not accessible');\n    }\n\n    // Check encryption availability\n    try {\n      const testKey = crypto.randomBytes(32);\n      const testIv = crypto.randomBytes(12);\n      const cipher = crypto.createCipheriv('aes-256-gcm', testKey, testIv);\n      cipher.update('test');\n      cipher.final();\n    } catch {\n      encryptionAvailable = false;\n      errors.push('AES-256-GCM encryption not available');\n    }\n\n    // Count networks and wallets\n    for (const network of ['mainnet', 'testnet', 'devnet'] as XRPLNetwork[]) {\n      const networkDir = path.join(this.baseDir, network, 'wallets');\n      try {\n        await fs.access(networkDir);\n        networkCount++;\n        const files = await fs.readdir(networkDir);\n        walletCount += files.filter((f) => f.endsWith('.wallet.json')).length;\n      } catch {\n        // Network directory doesn't exist yet\n      }\n    }\n\n    const result: KeystoreHealthResult = {\n      healthy: storageAccessible && encryptionAvailable && errors.length === 0,\n      providerType: this.providerType,\n      providerVersion: this.providerVersion,\n      timestamp: new Date().toISOString(),\n      details: {\n        storageAccessible,\n        encryptionAvailable,\n        networkCount,\n        walletCount,\n      },\n    };\n    if (errors.length > 0) {\n      result.errors = errors;\n    }\n    return result;\n  }\n\n  async close(): Promise<void> {\n    // Clear rate limiting state\n    this.authAttempts.clear();\n    this.lockouts.clear();\n    this.initialized = false;\n  }\n\n  // ========================================================================\n  // Wallet CRUD Operations\n  // ========================================================================\n\n  async createWallet(\n    network: XRPLNetwork,\n    policy: WalletPolicy,\n    options?: WalletCreateOptions\n  ): Promise<WalletEntry> {\n    this.assertInitialized();\n\n    if (!options?.password) {\n      throw new WeakPasswordError(['Password is required']);\n    }\n\n    // Validate password\n    const passwordErrors = validatePassword(options.password, this.passwordPolicy);\n    if (passwordErrors.length > 0) {\n      throw new WeakPasswordError(passwordErrors);\n    }\n\n    // Check capacity\n    const currentCount = (await this.listWallets(network)).length;\n    if (currentCount >= this.maxWalletsPerNetwork) {\n      throw new KeystoreCapacityError(network, currentCount, this.maxWalletsPerNetwork);\n    }\n\n    // Generate wallet ID\n    const walletId = this.generateWalletId();\n\n    // Generate wallet using xrpl library\n    const algorithm = options?.algorithm || 'ed25519';\n    // Map our algorithm type to xrpl's ECDSA enum\n    const xrplAlgorithm = algorithm === 'secp256k1' ? ECDSA.secp256k1 : ECDSA.ed25519;\n    const xrplWallet = Wallet.generate(xrplAlgorithm);\n\n    // Get seed as buffer\n    const seedHex = xrplWallet.seed;\n    if (!seedHex) {\n      throw new KeystoreWriteError('Failed to generate wallet seed', 'create');\n    }\n\n    // Convert seed to buffer (xrpl seeds are base58, we'll store the entropy)\n    const seedBuffer = Buffer.from(xrplWallet.privateKey, 'hex');\n    const seed = SecureBuffer.from(seedBuffer);\n\n    try {\n      // Derive encryption key\n      const salt = crypto.randomBytes(ARGON2_CONFIG.saltLength);\n      const kek = await this.deriveKey(options.password, salt);\n\n      // Encrypt seed\n      const { encryptedData, iv, authTag } = await this.encrypt(seed.getBuffer(), kek);\n\n      // Zero KEK immediately\n      kek.dispose();\n\n      // Create wallet entry\n      const now = new Date().toISOString();\n      const entry: WalletEntry = {\n        walletId,\n        name: options?.name || `Wallet ${walletId.slice(0, 8)}`,\n        address: xrplWallet.classicAddress,\n        publicKey: xrplWallet.publicKey,\n        algorithm,\n        network,\n        policyId: policy.policyId,\n        encryption: {\n          algorithm: 'aes-256-gcm',\n          kdf: 'argon2id',\n          kdfParams: {\n            memoryCost: ARGON2_CONFIG.memoryCost,\n            timeCost: ARGON2_CONFIG.timeCost,\n            parallelism: ARGON2_CONFIG.parallelism,\n          },\n          salt: salt.toString('base64'),\n        },\n        metadata: {\n          ...(options?.description && { description: options.description }),\n          ...(options?.tags && { tags: options.tags }),\n        },\n        createdAt: now,\n        modifiedAt: now,\n        status: 'active',\n      };\n\n      // Create wallet file content\n      const walletFile: WalletFile = {\n        version: 1,\n        walletId,\n        entry,\n        encryptedKey: {\n          data: encryptedData.toString('base64'),\n          iv: iv.toString('base64'),\n          authTag: authTag.toString('base64'),\n        },\n      };\n\n      // Write wallet file atomically\n      const walletPath = this.getWalletPath(network, walletId);\n      await this.atomicWrite(walletPath, JSON.stringify(walletFile, null, 2));\n\n      // Update index\n      await this.updateIndex(network, entry, 'add');\n\n      return entry;\n    } finally {\n      // Always zero seed\n      seed.dispose();\n    }\n  }\n\n  async loadKey(walletId: string, password: string): Promise<SecureBuffer> {\n    this.assertInitialized();\n\n    // Check rate limiting\n    this.checkRateLimit(walletId);\n\n    try {\n      // Find wallet file\n      const { walletFile } = await this.findWallet(walletId);\n\n      // Derive KEK from password\n      const salt = Buffer.from(walletFile.entry.encryption.salt, 'base64');\n      const kek = await this.deriveKey(password, salt);\n\n      try {\n        // Decrypt key material\n        const encryptedData = Buffer.from(walletFile.encryptedKey.data, 'base64');\n        const iv = Buffer.from(walletFile.encryptedKey.iv, 'base64');\n        const authTag = Buffer.from(walletFile.encryptedKey.authTag, 'base64');\n\n        const decrypted = await this.decrypt(encryptedData, kek, iv, authTag);\n\n        // Record successful auth\n        this.recordAuthSuccess(walletId);\n\n        return decrypted;\n      } finally {\n        kek.dispose();\n      }\n    } catch (error) {\n      // Record failed auth attempt\n      if (error instanceof AuthenticationError || error instanceof KeyDecryptionError) {\n        this.recordAuthFailure(walletId);\n      }\n      throw error;\n    }\n  }\n\n  async storeKey(\n    walletId: string,\n    key: SecureBuffer,\n    password: string,\n    metadata: WalletMetadata\n  ): Promise<void> {\n    this.assertInitialized();\n\n    // Validate password\n    const passwordErrors = validatePassword(password, this.passwordPolicy);\n    if (passwordErrors.length > 0) {\n      throw new WeakPasswordError(passwordErrors);\n    }\n\n    // Check if wallet already exists\n    try {\n      await this.findWallet(walletId);\n      throw new WalletExistsError(walletId);\n    } catch (error) {\n      if (!(error instanceof WalletNotFoundError)) {\n        throw error;\n      }\n    }\n\n    // Validate key format - must be 16 bytes (128-bit entropy)\n    const keyBuffer = key.getBuffer();\n    if (keyBuffer.length !== 16) {\n      throw new InvalidKeyError('Invalid key length', 'Expected 16 bytes (128-bit entropy)');\n    }\n\n    // Derive wallet from entropy (private key material)\n    let xrplWallet: Wallet;\n    try {\n      xrplWallet = Wallet.fromEntropy(keyBuffer);\n    } catch {\n      throw new InvalidKeyError('Could not derive wallet from key');\n    }\n\n    // Default to testnet for imported keys\n    const network: XRPLNetwork = 'testnet';\n\n    // Derive encryption key\n    const salt = crypto.randomBytes(ARGON2_CONFIG.saltLength);\n    const kek = await this.deriveKey(password, salt);\n\n    try {\n      // Encrypt key\n      const { encryptedData, iv, authTag } = await this.encrypt(keyBuffer, kek);\n\n      const now = new Date().toISOString();\n      const entry: WalletEntry = {\n        walletId,\n        name: walletId,\n        address: xrplWallet.classicAddress,\n        publicKey: xrplWallet.publicKey,\n        algorithm: 'ed25519',\n        network,\n        policyId: 'imported',\n        encryption: {\n          algorithm: 'aes-256-gcm',\n          kdf: 'argon2id',\n          kdfParams: {\n            memoryCost: ARGON2_CONFIG.memoryCost,\n            timeCost: ARGON2_CONFIG.timeCost,\n            parallelism: ARGON2_CONFIG.parallelism,\n          },\n          salt: salt.toString('base64'),\n        },\n        metadata,\n        createdAt: now,\n        modifiedAt: now,\n        status: 'active',\n      };\n\n      const walletFile: WalletFile = {\n        version: 1,\n        walletId,\n        entry,\n        encryptedKey: {\n          data: encryptedData.toString('base64'),\n          iv: iv.toString('base64'),\n          authTag: authTag.toString('base64'),\n        },\n      };\n\n      const walletPath = this.getWalletPath(network, walletId);\n      await this.atomicWrite(walletPath, JSON.stringify(walletFile, null, 2));\n\n      await this.updateIndex(network, entry, 'add');\n    } finally {\n      kek.dispose();\n    }\n  }\n\n  async listWallets(network?: XRPLNetwork): Promise<WalletSummary[]> {\n    this.assertInitialized();\n\n    const networks = network ? [network] : (['mainnet', 'testnet', 'devnet'] as XRPLNetwork[]);\n    const summaries: WalletSummary[] = [];\n\n    for (const net of networks) {\n      const indexPath = path.join(this.baseDir, net, 'index.json');\n      try {\n        const content = await fs.readFile(indexPath, 'utf-8');\n        const index: WalletIndex = JSON.parse(content);\n\n        for (const entry of index.wallets) {\n          const summary: WalletSummary = {\n            walletId: entry.walletId,\n            name: entry.name,\n            address: entry.address,\n            network: entry.network,\n            status: entry.status,\n            createdAt: entry.createdAt,\n            policyId: entry.policyId,\n          };\n          if (entry.metadata?.lastUsedAt) {\n            summary.lastUsedAt = entry.metadata.lastUsedAt;\n          }\n          if (entry.metadata?.tags) {\n            summary.tags = entry.metadata.tags;\n          }\n          summaries.push(summary);\n        }\n      } catch {\n        // Index doesn't exist yet\n      }\n    }\n\n    return summaries;\n  }\n\n  async getWallet(walletId: string): Promise<WalletEntry> {\n    this.assertInitialized();\n\n    const { walletFile } = await this.findWallet(walletId);\n    return walletFile.entry;\n  }\n\n  async deleteWallet(walletId: string, password: string): Promise<void> {\n    this.assertInitialized();\n\n    // Verify authentication\n    this.checkRateLimit(walletId);\n\n    const { network, walletFile, filePath } = await this.findWallet(walletId);\n\n    // Verify password by attempting to decrypt\n    const salt = Buffer.from(walletFile.entry.encryption.salt, 'base64');\n    const kek = await this.deriveKey(password, salt);\n\n    try {\n      const encryptedData = Buffer.from(walletFile.encryptedKey.data, 'base64');\n      const iv = Buffer.from(walletFile.encryptedKey.iv, 'base64');\n      const authTag = Buffer.from(walletFile.encryptedKey.authTag, 'base64');\n\n      const decrypted = await this.decrypt(encryptedData, kek, iv, authTag);\n      decrypted.dispose();\n\n      this.recordAuthSuccess(walletId);\n    } catch (error) {\n      this.recordAuthFailure(walletId);\n      throw error;\n    } finally {\n      kek.dispose();\n    }\n\n    // Delete wallet file\n    await this.fileLock.withLock(filePath, async () => {\n      // Overwrite file contents before deletion (secure delete)\n      const fileSize = (await fs.stat(filePath)).size;\n      const randomData = crypto.randomBytes(fileSize);\n      await fs.writeFile(filePath, randomData);\n      await fs.unlink(filePath);\n    });\n\n    // Update index\n    await this.updateIndex(network, walletFile.entry, 'remove');\n  }\n\n  async rotateKey(walletId: string, currentPassword: string, newPassword: string): Promise<void> {\n    this.assertInitialized();\n\n    // Validate new password\n    const passwordErrors = validatePassword(newPassword, this.passwordPolicy);\n    if (passwordErrors.length > 0) {\n      throw new WeakPasswordError(passwordErrors);\n    }\n\n    // Load current key\n    const key = await this.loadKey(walletId, currentPassword);\n\n    try {\n      const { network, walletFile, filePath } = await this.findWallet(walletId);\n\n      // Generate new salt and derive new KEK\n      const newSalt = crypto.randomBytes(ARGON2_CONFIG.saltLength);\n      const newKek = await this.deriveKey(newPassword, newSalt);\n\n      try {\n        // Re-encrypt with new key\n        const { encryptedData, iv, authTag } = await this.encrypt(key.getBuffer(), newKek);\n\n        // Update wallet file\n        walletFile.entry.encryption.salt = newSalt.toString('base64');\n        walletFile.entry.modifiedAt = new Date().toISOString();\n        walletFile.encryptedKey = {\n          data: encryptedData.toString('base64'),\n          iv: iv.toString('base64'),\n          authTag: authTag.toString('base64'),\n        };\n\n        // Write atomically\n        await this.atomicWrite(filePath, JSON.stringify(walletFile, null, 2));\n\n        // Update index\n        await this.updateIndex(network, walletFile.entry, 'update');\n      } finally {\n        newKek.dispose();\n      }\n    } finally {\n      key.dispose();\n    }\n  }\n\n  async updateMetadata(walletId: string, updates: Partial<WalletMetadata>): Promise<void> {\n    this.assertInitialized();\n\n    const { network, walletFile, filePath } = await this.findWallet(walletId);\n\n    // Update metadata\n    walletFile.entry.metadata = {\n      ...walletFile.entry.metadata,\n      ...updates,\n    };\n    walletFile.entry.modifiedAt = new Date().toISOString();\n\n    // Write atomically\n    await this.atomicWrite(filePath, JSON.stringify(walletFile, null, 2));\n\n    // Update index\n    await this.updateIndex(network, walletFile.entry, 'update');\n  }\n\n  async exportBackup(\n    walletId: string,\n    password: string,\n    format: BackupFormat\n  ): Promise<EncryptedBackup> {\n    this.assertInitialized();\n\n    // Verify password and load key\n    const key = await this.loadKey(walletId, password);\n\n    try {\n      const { walletFile } = await this.findWallet(walletId);\n\n      // Create backup payload\n      const payload = {\n        version: 1,\n        exportedAt: new Date().toISOString(),\n        wallet: {\n          entry: walletFile.entry,\n          seed: key.getBuffer().toString('hex'),\n        },\n      };\n\n      // Generate new salt for backup encryption\n      const backupSalt = crypto.randomBytes(ARGON2_CONFIG.saltLength);\n      const backupKek = await this.deriveKey(password, backupSalt);\n\n      try {\n        // Encrypt backup payload\n        const payloadBuffer = Buffer.from(JSON.stringify(payload));\n        const { encryptedData, iv, authTag } = await this.encrypt(payloadBuffer, backupKek);\n\n        // Calculate checksum\n        const checksum = crypto.createHash('sha256').update(encryptedData).digest('hex');\n\n        const backup: EncryptedBackup = {\n          version: 1,\n          format,\n          createdAt: new Date().toISOString(),\n          sourceProvider: this.providerType,\n          encryption: {\n            algorithm: 'aes-256-gcm',\n            kdf: 'argon2id',\n            kdfParams: {\n              memoryCost: ARGON2_CONFIG.memoryCost,\n              timeCost: ARGON2_CONFIG.timeCost,\n              parallelism: ARGON2_CONFIG.parallelism,\n            },\n            salt: backupSalt.toString('base64'),\n            iv: iv.toString('base64'),\n            authTag: authTag.toString('base64'),\n          },\n          payload: encryptedData.toString('base64'),\n          checksum,\n        };\n\n        return backup;\n      } finally {\n        backupKek.dispose();\n      }\n    } finally {\n      key.dispose();\n    }\n  }\n\n  async importBackup(\n    backup: EncryptedBackup,\n    password: string,\n    options?: ImportOptions\n  ): Promise<WalletEntry> {\n    this.assertInitialized();\n\n    // Validate backup format\n    if (backup.version !== 1) {\n      throw new BackupFormatError('Unsupported backup version', 1);\n    }\n\n    // Verify checksum\n    const payloadData = Buffer.from(backup.payload, 'base64');\n    const computedChecksum = crypto.createHash('sha256').update(payloadData).digest('hex');\n\n    if (computedChecksum !== backup.checksum) {\n      throw new BackupFormatError('Checksum verification failed');\n    }\n\n    // Derive KEK from password\n    const salt = Buffer.from(backup.encryption.salt, 'base64');\n    const kek = await this.deriveKey(password, salt);\n\n    let decryptedPayload: SecureBuffer;\n    try {\n      const iv = Buffer.from(backup.encryption.iv, 'base64');\n      const authTag = Buffer.from(backup.encryption.authTag, 'base64');\n\n      decryptedPayload = await this.decrypt(payloadData, kek, iv, authTag);\n    } finally {\n      kek.dispose();\n    }\n\n    try {\n      // Parse payload\n      const payload = JSON.parse(decryptedPayload.getBuffer().toString());\n\n      const walletId = options?.newName || payload.wallet.entry.walletId;\n      const targetNetwork = options?.targetNetwork || payload.wallet.entry.network;\n\n      // Check if wallet exists\n      try {\n        await this.findWallet(walletId);\n        if (!options?.force) {\n          throw new WalletExistsError(walletId);\n        }\n      } catch (error) {\n        if (!(error instanceof WalletNotFoundError)) {\n          throw error;\n        }\n      }\n\n      // Import the seed\n      const seedBuffer = Buffer.from(payload.wallet.seed, 'hex');\n      const seed = SecureBuffer.from(seedBuffer);\n\n      try {\n        // Store with potentially new password\n        const storePassword = options?.newPassword || password;\n\n        // Derive new encryption key\n        const newSalt = crypto.randomBytes(ARGON2_CONFIG.saltLength);\n        const newKek = await this.deriveKey(storePassword, newSalt);\n\n        try {\n          const { encryptedData, iv, authTag } = await this.encrypt(seed.getBuffer(), newKek);\n\n          const now = new Date().toISOString();\n          const entry: WalletEntry = {\n            ...payload.wallet.entry,\n            walletId,\n            network: targetNetwork,\n            encryption: {\n              algorithm: 'aes-256-gcm',\n              kdf: 'argon2id',\n              kdfParams: {\n                memoryCost: ARGON2_CONFIG.memoryCost,\n                timeCost: ARGON2_CONFIG.timeCost,\n                parallelism: ARGON2_CONFIG.parallelism,\n              },\n              salt: newSalt.toString('base64'),\n            },\n            modifiedAt: now,\n            metadata: {\n              ...(payload.wallet.entry.metadata || {}),\n              customData: {\n                ...(payload.wallet.entry.metadata?.customData || {}),\n                importedAt: now,\n                importedFrom: backup.sourceProvider,\n              },\n            },\n          };\n\n          const walletFile: WalletFile = {\n            version: 1,\n            walletId,\n            entry,\n            encryptedKey: {\n              data: encryptedData.toString('base64'),\n              iv: iv.toString('base64'),\n              authTag: authTag.toString('base64'),\n            },\n          };\n\n          const walletPath = this.getWalletPath(targetNetwork, walletId);\n          await this.atomicWrite(walletPath, JSON.stringify(walletFile, null, 2));\n\n          await this.updateIndex(targetNetwork, entry, 'add');\n\n          return entry;\n        } finally {\n          newKek.dispose();\n        }\n      } finally {\n        seed.dispose();\n      }\n    } finally {\n      decryptedPayload.dispose();\n    }\n  }\n\n  // ========================================================================\n  // Private Helper Methods\n  // ========================================================================\n\n  private assertInitialized(): void {\n    if (!this.initialized) {\n      throw new KeystoreInitializationError('Provider not initialized');\n    }\n  }\n\n  private async ensureDirectoryStructure(): Promise<void> {\n    // Create base directory\n    await fs.mkdir(this.baseDir, { recursive: true, mode: PERMISSIONS.DIRECTORY });\n\n    // Create network directories\n    for (const network of ['mainnet', 'testnet', 'devnet']) {\n      const walletsDir = path.join(this.baseDir, network, 'wallets');\n      await fs.mkdir(walletsDir, { recursive: true, mode: PERMISSIONS.DIRECTORY });\n    }\n\n    // Create backups directory\n    const backupDir = path.join(this.baseDir, 'backups');\n    await fs.mkdir(backupDir, { recursive: true, mode: PERMISSIONS.DIRECTORY });\n  }\n\n  private async verifyPermissions(): Promise<void> {\n    // Verify base directory permissions\n    const stats = await fs.stat(this.baseDir);\n    const mode = stats.mode & 0o777;\n\n    if (mode !== PERMISSIONS.DIRECTORY) {\n      // Attempt to fix\n      await fs.chmod(this.baseDir, PERMISSIONS.DIRECTORY);\n    }\n  }\n\n  private generateWalletId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = crypto.randomBytes(8).toString('hex');\n    return `wallet_${timestamp}_${random}`;\n  }\n\n  private getWalletPath(network: XRPLNetwork, walletId: string): string {\n    return path.join(this.baseDir, network, 'wallets', `${walletId}.wallet.json`);\n  }\n\n  private async findWallet(\n    walletId: string\n  ): Promise<{ network: XRPLNetwork; walletFile: WalletFile; filePath: string }> {\n    for (const network of ['mainnet', 'testnet', 'devnet'] as XRPLNetwork[]) {\n      const filePath = this.getWalletPath(network, walletId);\n      try {\n        const content = await fs.readFile(filePath, 'utf-8');\n        const walletFile: WalletFile = JSON.parse(content);\n        return { network, walletFile, filePath };\n      } catch {\n        // Not in this network\n      }\n    }\n    throw new WalletNotFoundError(walletId);\n  }\n\n  private async updateIndex(\n    network: XRPLNetwork,\n    entry: WalletEntry,\n    operation: 'add' | 'remove' | 'update'\n  ): Promise<void> {\n    const indexPath = path.join(this.baseDir, network, 'index.json');\n\n    await this.fileLock.withLock(indexPath, async () => {\n      let index: WalletIndex;\n\n      try {\n        const content = await fs.readFile(indexPath, 'utf-8');\n        index = JSON.parse(content);\n      } catch {\n        index = { version: 1, wallets: [], modifiedAt: '' };\n      }\n\n      switch (operation) {\n        case 'add':\n          index.wallets.push(entry);\n          break;\n        case 'remove':\n          index.wallets = index.wallets.filter((w) => w.walletId !== entry.walletId);\n          break;\n        case 'update':\n          index.wallets = index.wallets.map((w) => (w.walletId === entry.walletId ? entry : w));\n          break;\n      }\n\n      index.modifiedAt = new Date().toISOString();\n\n      await this.atomicWrite(indexPath, JSON.stringify(index, null, 2));\n    });\n  }\n\n  // ========================================================================\n  // Cryptographic Operations\n  // ========================================================================\n\n  /**\n   * Derives a 256-bit key from password using Argon2id.\n   */\n  private async deriveKey(password: string, salt: Buffer): Promise<SecureBuffer> {\n    const derivedKey = await argon2.hash(password, {\n      type: ARGON2_CONFIG.type,\n      memoryCost: ARGON2_CONFIG.memoryCost,\n      timeCost: ARGON2_CONFIG.timeCost,\n      parallelism: ARGON2_CONFIG.parallelism,\n      hashLength: ARGON2_CONFIG.hashLength,\n      salt,\n      raw: true, // Return raw bytes, not encoded string\n    });\n\n    return SecureBuffer.from(derivedKey);\n  }\n\n  /**\n   * Encrypts data using AES-256-GCM.\n   */\n  private async encrypt(\n    plaintext: Buffer,\n    key: SecureBuffer\n  ): Promise<{ encryptedData: Buffer; iv: Buffer; authTag: Buffer }> {\n    // Generate cryptographically secure random IV\n    const iv = crypto.randomBytes(AES_CONFIG.ivLength);\n\n    // Create cipher\n    const cipher = crypto.createCipheriv(AES_CONFIG.algorithm, key.getBuffer(), iv, {\n      authTagLength: AES_CONFIG.authTagLength,\n    });\n\n    // Encrypt\n    const encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);\n\n    // Get authentication tag\n    const authTag = cipher.getAuthTag();\n\n    return {\n      encryptedData: encrypted,\n      iv,\n      authTag,\n    };\n  }\n\n  /**\n   * Decrypts data using AES-256-GCM.\n   */\n  private async decrypt(\n    ciphertext: Buffer,\n    key: SecureBuffer,\n    iv: Buffer,\n    authTag: Buffer\n  ): Promise<SecureBuffer> {\n    try {\n      // Create decipher\n      const decipher = crypto.createDecipheriv(AES_CONFIG.algorithm, key.getBuffer(), iv, {\n        authTagLength: AES_CONFIG.authTagLength,\n      });\n\n      // Set auth tag BEFORE decryption (required for GCM)\n      decipher.setAuthTag(authTag);\n\n      // Decrypt\n      const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);\n\n      // Return as SecureBuffer for memory safety\n      return SecureBuffer.from(decrypted);\n    } catch (error) {\n      // GCM auth failure or other crypto error\n      if (error instanceof Error && error.message.includes('auth')) {\n        throw new AuthenticationError();\n      }\n      throw new KeyDecryptionError('Decryption failed');\n    }\n  }\n\n  // ========================================================================\n  // File System Operations\n  // ========================================================================\n\n  /**\n   * Atomically writes content to a file using temp file + rename pattern.\n   */\n  private async atomicWrite(filePath: string, content: string): Promise<void> {\n    const dir = path.dirname(filePath);\n    const tempPath = path.join(dir, `.${path.basename(filePath)}.tmp.${process.pid}`);\n\n    try {\n      // Write to temp file with secure permissions\n      await fs.writeFile(tempPath, content, {\n        encoding: 'utf-8',\n        mode: PERMISSIONS.FILE,\n      });\n\n      // Atomic rename\n      await fs.rename(tempPath, filePath);\n    } catch (error) {\n      // Clean up temp file on failure\n      try {\n        await fs.unlink(tempPath);\n      } catch {\n        // Ignore cleanup errors\n      }\n      throw new KeystoreWriteError(`Failed to write ${filePath}: ${error}`, 'create');\n    }\n  }\n\n  // ========================================================================\n  // Rate Limiting\n  // ========================================================================\n\n  /**\n   * Checks if wallet is currently locked out.\n   */\n  private checkRateLimit(walletId: string): void {\n    const lockout = this.lockouts.get(walletId);\n    if (lockout && lockout > new Date()) {\n      throw new AuthenticationError();\n    }\n\n    // Clean old lockout\n    if (lockout) {\n      this.lockouts.delete(walletId);\n    }\n  }\n\n  /**\n   * Records successful authentication.\n   */\n  private recordAuthSuccess(walletId: string): void {\n    this.authAttempts.delete(walletId);\n    this.lockouts.delete(walletId);\n  }\n\n  /**\n   * Records failed authentication attempt.\n   */\n  private recordAuthFailure(walletId: string): void {\n    const now = new Date();\n    const windowStart = new Date(now.getTime() - RATE_LIMIT_CONFIG.windowSeconds * 1000);\n\n    // Get or create attempt list\n    let attempts = this.authAttempts.get(walletId) || [];\n\n    // Filter to recent attempts\n    attempts = attempts.filter((a) => a.timestamp > windowStart);\n\n    // Add new failure\n    attempts.push({ timestamp: now, success: false });\n    this.authAttempts.set(walletId, attempts);\n\n    // Check if lockout needed\n    const failures = attempts.filter((a) => !a.success).length;\n    if (failures >= RATE_LIMIT_CONFIG.maxAttempts) {\n      // Calculate lockout duration (progressive)\n      const lockoutCount = Math.floor(failures / RATE_LIMIT_CONFIG.maxAttempts);\n      const duration =\n        RATE_LIMIT_CONFIG.lockoutSeconds *\n        Math.pow(RATE_LIMIT_CONFIG.lockoutMultiplier, lockoutCount - 1);\n\n      const lockoutUntil = new Date(now.getTime() + duration * 1000);\n      this.lockouts.set(walletId, lockoutUntil);\n    }\n  }\n}\n","/**\n * Keystore Module\n *\n * Provides secure key storage functionality for the XRPL Agent Wallet MCP server.\n *\n * Features:\n * - Pluggable provider interface (IKeystore)\n * - Memory-safe key handling (SecureBuffer)\n * - Local file-based storage with AES-256-GCM encryption (LocalKeystore)\n * - Argon2id key derivation for password protection\n * - Network-isolated storage (mainnet/testnet/devnet)\n *\n * @module keystore\n * @version 1.0.0\n */\n\n// Interface and types\nexport type {\n  KeystoreProvider,\n  KeystoreConfig,\n  KeystoreHealthResult,\n  XRPLNetwork,\n  KeystoreProviderType,\n  KeyAlgorithm,\n  WalletStatus,\n  BackupFormat,\n  PasswordPolicy,\n  AuditConfig,\n  HSMConfig,\n  KdfParams,\n  EncryptionMetadata,\n  WalletMetadata,\n  WalletEntry,\n  WalletSummary,\n  WalletPolicy,\n  WalletCreateOptions,\n  EntropySource,\n  EncryptedBackup,\n  ImportOptions,\n} from './interface.js';\n\n// SecureBuffer for memory-safe key handling\nexport { SecureBuffer } from './secure-buffer.js';\n\n// Error types\nexport {\n  KeystoreError,\n  KeystoreInitializationError,\n  WalletNotFoundError,\n  WalletExistsError,\n  AuthenticationError,\n  WeakPasswordError,\n  KeyDecryptionError,\n  KeyEncryptionError,\n  InvalidKeyError,\n  KeystoreWriteError,\n  KeystoreReadError,\n  KeystoreCapacityError,\n  BackupFormatError,\n  NetworkMismatchError,\n  ProviderUnavailableError,\n  isKeystoreError,\n  isKeystoreErrorCode,\n  type KeystoreErrorCode,\n} from './errors.js';\n\n// LocalKeystore implementation\nexport { LocalKeystore } from './local.js';\n\n/**\n * Default password policy for keystore operations.\n *\n * Requirements:\n * - Minimum 12 characters\n * - At least one uppercase letter\n * - At least one lowercase letter\n * - At least one number\n * - Maximum 128 characters\n */\nexport const DEFAULT_PASSWORD_POLICY = {\n  minLength: 12,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecial: false,\n  maxLength: 128,\n} as const;\n\n/**\n * Argon2id KDF configuration per ADR-002.\n *\n * Parameters:\n * - memoryCost: 64MB\n * - timeCost: 3 iterations\n * - parallelism: 4 threads\n * - hashLength: 32 bytes (256 bits)\n */\nexport const ARGON2_CONFIG = {\n  memoryCost: 65536, // 64 MB\n  timeCost: 3, // 3 iterations\n  parallelism: 4, // 4 threads\n  hashLength: 32, // 256-bit output\n  saltLength: 32, // 256-bit salt\n} as const;\n\n/**\n * AES-256-GCM encryption configuration per ADR-001.\n *\n * Parameters:\n * - keyLength: 32 bytes (256 bits)\n * - ivLength: 12 bytes (96 bits, NIST recommended)\n * - authTagLength: 16 bytes (128 bits)\n */\nexport const AES_CONFIG = {\n  algorithm: 'aes-256-gcm',\n  keyLength: 32, // 256 bits\n  ivLength: 12, // 96 bits\n  authTagLength: 16, // 128 bits\n} as const;\n","/**\n * XRPL Network Configuration\n *\n * Provides network-specific configuration for XRPL connections including\n * WebSocket endpoints, explorers, and faucets.\n *\n * @module xrpl/config\n * @version 1.0.0\n * @since 2026-01-28\n */\n\nimport type { Network } from '../schemas/index.js';\n\n/**\n * Network connection endpoints\n */\nexport interface NetworkEndpoints {\n  /** WebSocket endpoints for this network */\n  websocket: {\n    /** Primary WebSocket URL */\n    primary: string;\n    /** Backup WebSocket URLs */\n    backup: string[];\n  };\n  /** JSON-RPC endpoints (optional) */\n  jsonRpc?: {\n    /** Primary JSON-RPC URL */\n    primary: string;\n    /** Backup JSON-RPC URLs */\n    backup: string[];\n  };\n}\n\n/**\n * Explorer URL functions\n */\nexport interface ExplorerUrls {\n  /** Main explorer URL */\n  home: string;\n  /** Account/wallet lookup */\n  account: (address: string) => string;\n  /** Transaction lookup */\n  transaction: (hash: string) => string;\n  /** Ledger lookup */\n  ledger: (index: number) => string;\n}\n\n/**\n * Faucet configuration\n */\nexport interface FaucetConfig {\n  /** Whether faucet is available for this network */\n  available: boolean;\n  /** Faucet API endpoint */\n  url?: string;\n  /** Amount dispensed per request (XRP) */\n  amountXrp?: number;\n  /** Rate limit window in seconds */\n  rateLimitSeconds?: number;\n  /** Rate limit requests per window */\n  rateLimitRequests?: number;\n}\n\n/**\n * Connection configuration\n */\nexport interface ConnectionConfig {\n  /** Connection timeout in milliseconds */\n  connectionTimeout: number;\n  /** Request timeout in milliseconds */\n  requestTimeout: number;\n  /** Maximum reconnection attempts */\n  maxReconnectAttempts: number;\n  /** Initial reconnection delay in milliseconds */\n  reconnectDelay: number;\n  /** Reconnection backoff multiplier */\n  reconnectBackoff: number;\n}\n\n/**\n * Default network endpoints\n *\n * IMPORTANT: These are the official public endpoints. For production,\n * consider using a private node via environment variable override.\n */\nexport const NETWORK_ENDPOINTS: Record<Network, NetworkEndpoints> = {\n  mainnet: {\n    websocket: {\n      primary: 'wss://xrplcluster.com',\n      backup: ['wss://s1.ripple.com', 'wss://s2.ripple.com'],\n    },\n    jsonRpc: {\n      primary: 'https://xrplcluster.com',\n      backup: ['https://s1.ripple.com:51234', 'https://s2.ripple.com:51234'],\n    },\n  },\n  testnet: {\n    websocket: {\n      primary: 'wss://s.altnet.rippletest.net:51233',\n      backup: ['wss://testnet.xrpl-labs.com'],\n    },\n    jsonRpc: {\n      primary: 'https://s.altnet.rippletest.net:51234',\n      backup: [],\n    },\n  },\n  devnet: {\n    websocket: {\n      primary: 'wss://s.devnet.rippletest.net:51233',\n      backup: [],\n    },\n    jsonRpc: {\n      primary: 'https://s.devnet.rippletest.net:51234',\n      backup: [],\n    },\n  },\n};\n\n/**\n * Block explorer URLs\n */\nexport const EXPLORER_URLS: Record<Network, ExplorerUrls> = {\n  mainnet: {\n    home: 'https://xrpscan.com',\n    account: (address) => `https://xrpscan.com/account/${address}`,\n    transaction: (hash) => `https://xrpscan.com/tx/${hash}`,\n    ledger: (index) => `https://xrpscan.com/ledger/${index}`,\n  },\n  testnet: {\n    home: 'https://testnet.xrpl.org',\n    account: (address) => `https://testnet.xrpl.org/accounts/${address}`,\n    transaction: (hash) => `https://testnet.xrpl.org/transactions/${hash}`,\n    ledger: (index) => `https://testnet.xrpl.org/ledgers/${index}`,\n  },\n  devnet: {\n    home: 'https://devnet.xrpl.org',\n    account: (address) => `https://devnet.xrpl.org/accounts/${address}`,\n    transaction: (hash) => `https://devnet.xrpl.org/transactions/${hash}`,\n    ledger: (index) => `https://devnet.xrpl.org/ledgers/${index}`,\n  },\n};\n\n/**\n * Faucet configuration by network\n */\nexport const FAUCET_CONFIG: Record<Network, FaucetConfig> = {\n  mainnet: {\n    available: false,\n    // No faucet for mainnet - real XRP must be acquired through exchanges\n  },\n  testnet: {\n    available: true,\n    url: 'https://faucet.altnet.rippletest.net/accounts',\n    amountXrp: 1000,\n    rateLimitSeconds: 60,\n    rateLimitRequests: 1,\n  },\n  devnet: {\n    available: true,\n    url: 'https://faucet.devnet.rippletest.net/accounts',\n    amountXrp: 1000,\n    rateLimitSeconds: 60,\n    rateLimitRequests: 1,\n  },\n};\n\n/**\n * Default connection configuration\n */\nexport const DEFAULT_CONNECTION_CONFIG: ConnectionConfig = {\n  connectionTimeout: 10000, // 10 seconds\n  requestTimeout: 30000, // 30 seconds\n  maxReconnectAttempts: 3,\n  reconnectDelay: 1000, // 1 second\n  reconnectBackoff: 2, // Exponential backoff multiplier\n};\n\n/**\n * Get WebSocket URL for a network\n *\n * Checks for environment variable override first, then uses default.\n *\n * @param network - Target network\n * @returns WebSocket URL\n * @throws {Error} If custom URL doesn't use WSS protocol\n */\nexport function getWebSocketUrl(network: Network): string {\n  // Check for environment override\n  const envKey = `XRPL_${network.toUpperCase()}_WEBSOCKET_URL`;\n  const customUrl = process.env[envKey];\n\n  if (customUrl) {\n    // Validate custom URL uses secure WebSocket\n    if (!customUrl.startsWith('wss://') && !customUrl.startsWith('ws://localhost')) {\n      throw new Error(\n        `Custom endpoint must use WSS or ws://localhost: ${envKey}=${customUrl}`\n      );\n    }\n    return customUrl;\n  }\n\n  return NETWORK_ENDPOINTS[network].websocket.primary;\n}\n\n/**\n * Get backup WebSocket URLs for a network\n *\n * @param network - Target network\n * @returns Array of backup WebSocket URLs\n */\nexport function getBackupWebSocketUrls(network: Network): string[] {\n  return NETWORK_ENDPOINTS[network].websocket.backup;\n}\n\n/**\n * Get explorer URL for a transaction\n *\n * @param hash - Transaction hash\n * @param network - Network the transaction is on\n * @returns Explorer URL\n */\nexport function getTransactionExplorerUrl(hash: string, network: Network): string {\n  return EXPLORER_URLS[network].transaction(hash);\n}\n\n/**\n * Get explorer URL for an account\n *\n * @param address - Account address\n * @param network - Network the account is on\n * @returns Explorer URL\n */\nexport function getAccountExplorerUrl(address: string, network: Network): string {\n  return EXPLORER_URLS[network].account(address);\n}\n\n/**\n * Get explorer URL for a ledger\n *\n * @param index - Ledger index\n * @param network - Network the ledger is on\n * @returns Explorer URL\n */\nexport function getLedgerExplorerUrl(index: number, network: Network): string {\n  return EXPLORER_URLS[network].ledger(index);\n}\n\n/**\n * Check if faucet is available for a network\n *\n * @param network - Network to check\n * @returns True if faucet is available\n */\nexport function isFaucetAvailable(network: Network): boolean {\n  return FAUCET_CONFIG[network].available;\n}\n\n/**\n * Get faucet URL for a network\n *\n * @param network - Network to get faucet for\n * @returns Faucet URL or null if not available\n */\nexport function getFaucetUrl(network: Network): string | null {\n  const config = FAUCET_CONFIG[network];\n  return config.available ? config.url! : null;\n}\n\n/**\n * Get connection configuration with environment overrides\n *\n * @returns Connection configuration\n */\nexport function getConnectionConfig(): ConnectionConfig {\n  const env = process.env as Record<string, string | undefined>;\n\n  return {\n    connectionTimeout: parseInt(\n      env['XRPL_CONNECTION_TIMEOUT'] ?? String(DEFAULT_CONNECTION_CONFIG.connectionTimeout)\n    ),\n    requestTimeout: parseInt(\n      env['XRPL_REQUEST_TIMEOUT'] ?? String(DEFAULT_CONNECTION_CONFIG.requestTimeout)\n    ),\n    maxReconnectAttempts: parseInt(\n      env['XRPL_MAX_RECONNECT_ATTEMPTS'] ??\n        String(DEFAULT_CONNECTION_CONFIG.maxReconnectAttempts)\n    ),\n    reconnectDelay: DEFAULT_CONNECTION_CONFIG.reconnectDelay,\n    reconnectBackoff: DEFAULT_CONNECTION_CONFIG.reconnectBackoff,\n  };\n}\n","/**\n * XRPL Client Wrapper\n *\n * Provides a robust wrapper around xrpl.js with connection management,\n * automatic retries, and transaction helpers.\n *\n * @module xrpl/client\n * @version 1.0.0\n * @since 2026-01-28\n */\n\nimport { Client, type TxResponse, type AccountInfoResponse, type SubmitResponse } from 'xrpl';\nimport type { Network, XRPLAddress, TransactionHash } from '../schemas/index.js';\nimport {\n  getWebSocketUrl,\n  getBackupWebSocketUrls,\n  getConnectionConfig,\n  type ConnectionConfig,\n} from './config.js';\n\n/**\n * XRPL Client configuration\n */\nexport interface XRPLClientConfig {\n  /** Target network */\n  network: Network;\n  /** Custom WebSocket URL (overrides network default) */\n  nodeUrl?: string;\n  /** Connection configuration */\n  connectionConfig?: Partial<ConnectionConfig>;\n}\n\n/**\n * Account information from XRPL\n */\nexport interface AccountInfo {\n  /** Account address */\n  account: string;\n  /** Balance in drops */\n  balance: string;\n  /** Account sequence number */\n  sequence: number;\n  /** Number of objects owned (affects reserve) */\n  ownerCount: number;\n  /** Account flags */\n  flags: number;\n  /** Previous transaction ID */\n  previousTxnID: string;\n  /** Previous transaction ledger sequence */\n  previousTxnLgrSeq: number;\n}\n\n/**\n * XRPL transaction submission result\n */\nexport interface XRPLTransactionResult {\n  /** Transaction hash */\n  hash: string;\n  /** Result code (e.g., \"tesSUCCESS\") */\n  resultCode: string;\n  /** Ledger index where validated */\n  ledgerIndex: number | undefined;\n  /** Whether transaction was validated */\n  validated: boolean;\n  /** Transaction metadata */\n  meta: unknown | undefined;\n}\n\n/**\n * Transaction history options\n */\nexport interface TxHistoryOptions {\n  /** Maximum number of transactions to return */\n  limit?: number;\n  /** Oldest ledger index */\n  ledgerIndexMin?: number;\n  /** Newest ledger index */\n  ledgerIndexMax?: number;\n  /** Return transactions in chronological order */\n  forward?: boolean;\n}\n\n/**\n * Submit options for transactions\n */\nexport interface SubmitOptions {\n  /** Wait for validation (default: true) */\n  waitForValidation?: boolean;\n  /** Timeout for validation wait in ms (default: 20000) */\n  timeout?: number;\n  /** Fail if transaction not in validated ledger */\n  failHard?: boolean;\n}\n\n/**\n * Wait options for transaction validation\n */\nexport interface WaitOptions {\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Poll interval in milliseconds */\n  pollInterval?: number;\n}\n\n/**\n * Server information\n */\nexport interface ServerInfo {\n  /** Server state (e.g., \"full\", \"syncing\") */\n  server_state: string;\n  /** Validated ledger information */\n  validated_ledger:\n    | {\n        /** Ledger index */\n        seq: number;\n        /** Ledger hash */\n        hash: string;\n        /** Base reserve in XRP */\n        reserve_base_xrp: number;\n        /** Incremental reserve in XRP */\n        reserve_inc_xrp: number;\n        /** Base fee in XRP */\n        base_fee_xrp: number;\n      }\n    | undefined;\n  /** Complete ledgers range */\n  complete_ledgers: string;\n  /** Number of peers */\n  peers: number | undefined;\n  /** Validation quorum */\n  validation_quorum: number | undefined;\n}\n\n/**\n * Custom error for XRPL client operations\n */\nexport class XRPLClientError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'XRPLClientError';\n  }\n}\n\n/**\n * Connection failed error\n */\nexport class ConnectionError extends XRPLClientError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'CONNECTION_ERROR', details);\n    this.name = 'ConnectionError';\n  }\n}\n\n/**\n * Account not found error\n */\nexport class AccountNotFoundError extends XRPLClientError {\n  constructor(address: string) {\n    super(`Account not found: ${address}`, 'ACCOUNT_NOT_FOUND', { address });\n    this.name = 'AccountNotFoundError';\n  }\n}\n\n/**\n * Transaction timeout error\n */\nexport class TransactionTimeoutError extends XRPLClientError {\n  constructor(hash: string) {\n    super(`Transaction not validated: ${hash}`, 'TX_TIMEOUT', { hash });\n    this.name = 'TransactionTimeoutError';\n  }\n}\n\n/**\n * Max reconnect attempts error\n */\nexport class MaxReconnectAttemptsError extends XRPLClientError {\n  constructor(attempts: number) {\n    super(`Maximum reconnection attempts reached: ${attempts}`, 'MAX_RECONNECT', { attempts });\n    this.name = 'MaxReconnectAttemptsError';\n  }\n}\n\n/**\n * Helper to sleep for specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * XRPL Client Wrapper\n *\n * Provides connection management, auto-reconnection, and transaction helpers\n * for interacting with the XRPL.\n */\nexport class XRPLClientWrapper {\n  private client: Client;\n  private readonly network: Network;\n  private readonly nodeUrl: string;\n  private readonly backupUrls: string[];\n  private readonly connectionConfig: ConnectionConfig;\n  private currentUrlIndex: number = 0;\n  private reconnectAttempts: number = 0;\n  private isConnected: boolean = false;\n\n  /**\n   * Create a new XRPL client wrapper\n   *\n   * @param config - Client configuration\n   */\n  constructor(config: XRPLClientConfig) {\n    this.network = config.network;\n    this.nodeUrl = config.nodeUrl ?? getWebSocketUrl(config.network);\n    this.backupUrls = getBackupWebSocketUrls(config.network);\n    this.connectionConfig = {\n      ...getConnectionConfig(),\n      ...config.connectionConfig,\n    };\n\n    // Initialize xrpl.js client\n    this.client = new Client(this.nodeUrl);\n  }\n\n  /**\n   * Get the current network\n   */\n  public getNetwork(): Network {\n    return this.network;\n  }\n\n  /**\n   * Check if client is connected\n   */\n  public isClientConnected(): boolean {\n    return this.isConnected && this.client.isConnected();\n  }\n\n  /**\n   * Connect to XRPL network\n   *\n   * @throws {ConnectionError} If connection fails after all retries\n   */\n  public async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n      this.isConnected = true;\n      this.reconnectAttempts = 0;\n    } catch (error) {\n      this.isConnected = false;\n      throw new ConnectionError(`Failed to connect to ${this.nodeUrl}`, error);\n    }\n  }\n\n  /**\n   * Disconnect from XRPL network\n   */\n  public async disconnect(): Promise<void> {\n    if (this.client.isConnected()) {\n      await this.client.disconnect();\n    }\n    this.isConnected = false;\n  }\n\n  /**\n   * Reconnect with exponential backoff\n   *\n   * @throws {MaxReconnectAttemptsError} If max attempts exceeded\n   */\n  private async reconnect(): Promise<void> {\n    if (this.reconnectAttempts >= this.connectionConfig.maxReconnectAttempts) {\n      throw new MaxReconnectAttemptsError(this.reconnectAttempts);\n    }\n\n    // Calculate backoff delay\n    const delay = Math.min(\n      this.connectionConfig.reconnectDelay *\n        Math.pow(this.connectionConfig.reconnectBackoff, this.reconnectAttempts),\n      30000 // Max 30 seconds\n    );\n\n    await sleep(delay);\n\n    this.reconnectAttempts++;\n\n    try {\n      // Try backup URLs if available\n      if (this.reconnectAttempts > 1 && this.backupUrls.length > 0) {\n        this.currentUrlIndex = (this.currentUrlIndex + 1) % (this.backupUrls.length + 1);\n        const url =\n          this.currentUrlIndex === 0 ? this.nodeUrl : this.backupUrls[this.currentUrlIndex - 1]!;\n\n        // Create new client with backup URL\n        await this.client.disconnect();\n        this.client = new Client(url);\n      }\n\n      await this.client.connect();\n      this.isConnected = true;\n      this.reconnectAttempts = 0;\n    } catch (error) {\n      // Recursive retry\n      await this.reconnect();\n    }\n  }\n\n  /**\n   * Check server health\n   *\n   * @returns True if server is healthy (state is \"full\")\n   */\n  public async isHealthy(): Promise<boolean> {\n    try {\n      const response = await this.client.request({\n        command: 'server_state',\n      });\n      return response.result.state.server_state === 'full';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get server information\n   *\n   * @returns Server information\n   */\n  public async getServerInfo(): Promise<ServerInfo> {\n    const response = await this.client.request({\n      command: 'server_info',\n    });\n\n    const info = response.result.info;\n    return {\n      server_state: info.server_state,\n      validated_ledger: info.validated_ledger ?? undefined,\n      complete_ledgers: info.complete_ledgers,\n      peers: info.peers ?? undefined,\n      validation_quorum: info.validation_quorum ?? undefined,\n    };\n  }\n\n  /**\n   * Get account information\n   *\n   * @param address - Account address\n   * @returns Account information\n   * @throws {AccountNotFoundError} If account doesn't exist\n   */\n  public async getAccountInfo(address: XRPLAddress): Promise<AccountInfo> {\n    try {\n      const response = (await this.client.request({\n        command: 'account_info',\n        account: address,\n        ledger_index: 'validated',\n      })) as AccountInfoResponse;\n\n      const data = response.result.account_data;\n      return {\n        account: data.Account,\n        balance: data.Balance,\n        sequence: data.Sequence,\n        ownerCount: data.OwnerCount,\n        flags: data.Flags,\n        previousTxnID: data.PreviousTxnID,\n        previousTxnLgrSeq: data.PreviousTxnLgrSeq,\n      };\n    } catch (error: unknown) {\n      if (typeof error === 'object' && error !== null && 'data' in error) {\n        const errorData = error as { data?: { error?: string } };\n        if (errorData.data?.error === 'actNotFound') {\n          throw new AccountNotFoundError(address);\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get account balance in drops\n   *\n   * @param address - Account address\n   * @returns Balance in drops\n   */\n  public async getBalance(address: XRPLAddress): Promise<string> {\n    const accountInfo = await this.getAccountInfo(address);\n    return accountInfo.balance;\n  }\n\n  /**\n   * Get transaction information\n   *\n   * @param hash - Transaction hash\n   * @returns Transaction response\n   */\n  public async getTransaction(hash: TransactionHash): Promise<TxResponse> {\n    return this.client.request({\n      command: 'tx',\n      transaction: hash,\n    }) as Promise<TxResponse>;\n  }\n\n  /**\n   * Wait for transaction validation\n   *\n   * @param hash - Transaction hash\n   * @param options - Wait options\n   * @returns Transaction result\n   * @throws {TransactionTimeoutError} If transaction not validated within timeout\n   */\n  public async waitForTransaction(\n    hash: TransactionHash,\n    options: WaitOptions = {}\n  ): Promise<XRPLTransactionResult> {\n    const timeout = options.timeout ?? 20000;\n    const pollInterval = options.pollInterval ?? 1000;\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      try {\n        const response = await this.client.request({\n          command: 'tx',\n          transaction: hash,\n        });\n\n        if (response.result.validated) {\n          const meta = response.result.meta;\n          const transactionResult =\n            typeof meta === 'object' && meta !== null && 'XRPLTransactionResult' in meta\n              ? (meta.XRPLTransactionResult as string)\n              : 'unknown';\n\n          return {\n            hash,\n            resultCode: transactionResult,\n            ledgerIndex: response.result.ledger_index,\n            validated: true,\n            meta: response.result.meta,\n          };\n        }\n      } catch (error: unknown) {\n        // Transaction not found yet - keep waiting\n        if (typeof error === 'object' && error !== null && 'data' in error) {\n          const errorData = error as { data?: { error?: string } };\n          if (errorData.data?.error !== 'txnNotFound') {\n            throw error;\n          }\n        }\n      }\n\n      await sleep(pollInterval);\n    }\n\n    throw new TransactionTimeoutError(hash);\n  }\n\n  /**\n   * Get current ledger index\n   *\n   * @returns Current validated ledger index\n   */\n  public async getCurrentLedgerIndex(): Promise<number> {\n    const response = await this.client.request({\n      command: 'ledger',\n      ledger_index: 'validated',\n    });\n    return response.result.ledger_index;\n  }\n\n  /**\n   * Get fee estimate for a transaction\n   *\n   * @returns Estimated fee in drops\n   */\n  public async getFee(): Promise<string> {\n    const response = await this.client.request({\n      command: 'fee',\n    });\n    return response.result.drops.open_ledger_fee;\n  }\n\n  /**\n   * Get account transaction history\n   *\n   * @param address - Account address\n   * @param options - History options\n   * @returns Array of transactions\n   */\n  public async getAccountTransactions(\n    address: XRPLAddress,\n    options: TxHistoryOptions = {}\n  ): Promise<unknown[]> {\n    const response = await this.client.request({\n      command: 'account_tx',\n      account: address,\n      ledger_index_min: options.ledgerIndexMin ?? -1,\n      ledger_index_max: options.ledgerIndexMax ?? -1,\n      limit: Math.min(options.limit ?? 50, 400),\n      forward: options.forward ?? false,\n    });\n\n    return response.result.transactions.map((tx) => (tx as { tx: unknown }).tx);\n  }\n\n  /**\n   * Submit a signed transaction\n   *\n   * @param signedTx - Signed transaction blob (hex string)\n   * @param options - Submit options\n   * @returns Transaction result\n   */\n  public async submitSignedTransaction(\n    signedTx: string,\n    options: SubmitOptions = {}\n  ): Promise<XRPLTransactionResult> {\n    const opts = {\n      waitForValidation: true,\n      timeout: 20000,\n      failHard: false,\n      ...options,\n    };\n\n    // Submit transaction\n    const response = (await this.client.submit(signedTx, {\n      failHard: opts.failHard,\n    })) as SubmitResponse;\n\n    const { tx_json, engine_result, engine_result_message } = response.result;\n    const hash = tx_json.hash ?? 'unknown';\n\n    // Check if submission succeeded\n    if (engine_result !== 'tesSUCCESS' && !engine_result.startsWith('ter')) {\n      throw new XRPLClientError(\n        `Transaction submission failed: ${engine_result} - ${engine_result_message}`,\n        'TX_SUBMIT_FAILED',\n        { hash, engine_result, engine_result_message }\n      );\n    }\n\n    // Wait for validation if requested\n    if (opts.waitForValidation) {\n      return this.waitForTransaction(hash as TransactionHash, { timeout: opts.timeout });\n    }\n\n    return {\n      hash,\n      resultCode: engine_result,\n      ledgerIndex: undefined,\n      validated: false,\n      meta: undefined,\n    };\n  }\n}\n","/**\n * Signing Service Implementation\n *\n * Orchestrates transaction signing with secure key material handling.\n * Coordinates with keystore, policy engine, and multi-sign orchestrator.\n *\n * @module signing/service\n * @version 1.0.0\n */\n\nimport { Wallet, decode, encode, type Transaction } from 'xrpl';\nimport type { KeystoreProvider } from '../keystore/interface.js';\nimport { SecureBuffer } from '../keystore/secure-buffer.js';\nimport type { AuditLogger } from '../audit/logger.js';\nimport type { MultiSignOrchestrator } from './multisig.js';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Result of a single-sign operation.\n */\nexport interface SignedTransaction {\n  /**\n   * Signed transaction blob (hex encoded).\n   */\n  tx_blob: string;\n\n  /**\n   * Transaction hash.\n   */\n  hash: string;\n\n  /**\n   * Wallet address that signed.\n   */\n  signer_address: string;\n}\n\n/**\n * Error class for signing operations.\n */\nexport class SigningError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'SigningError';\n  }\n}\n\n// ============================================================================\n// SIGNING SERVICE\n// ============================================================================\n\n/**\n * SigningService - Orchestrates secure transaction signing.\n *\n * Responsibilities:\n * - Load wallet keys from keystore securely\n * - Sign transactions with proper XRPL formatting\n * - Zero key material immediately after use\n * - Audit all signing operations\n * - Coordinate multi-signature workflows\n *\n * Security Features:\n * - Uses SecureBuffer for key material\n * - Never exposes private keys to calling code\n * - Validates transaction format before signing\n * - Logs all signing attempts (success and failure)\n *\n * @example\n * ```typescript\n * const signer = new SigningService(keystore, auditLogger);\n *\n * // Single-sign transaction\n * const result = await signer.sign(\n *   'wallet_123',\n *   unsignedTxBlob,\n *   password\n * );\n *\n * console.log('Signed:', result.tx_blob);\n * console.log('Hash:', result.hash);\n * ```\n */\nexport class SigningService {\n  constructor(\n    private readonly keystore: KeystoreProvider,\n    private readonly auditLogger: AuditLogger,\n    private readonly multiSignOrchestrator?: MultiSignOrchestrator\n  ) {}\n\n  /**\n   * Sign a transaction with a wallet's private key.\n   *\n   * Process:\n   * 1. Decode unsigned transaction blob\n   * 2. Validate transaction structure\n   * 3. Load wallet key from keystore (SecureBuffer)\n   * 4. Create XRPL Wallet instance\n   * 5. Sign transaction\n   * 6. Zero key material\n   * 7. Return signed blob + hash\n   *\n   * @param walletId - Internal wallet identifier\n   * @param unsignedTx - Unsigned transaction blob (hex) or Transaction object\n   * @param password - User password for key decryption\n   * @param multiSign - Whether to sign for multi-signature (default: false)\n   * @returns Signed transaction with hash\n   *\n   * @throws SigningError TRANSACTION_DECODE_ERROR - Invalid transaction format\n   * @throws SigningError WALLET_NOT_FOUND - Wallet doesn't exist\n   * @throws SigningError AUTHENTICATION_FAILED - Incorrect password\n   * @throws SigningError SIGNING_FAILED - Cryptographic signing error\n   */\n  async sign(\n    walletId: string,\n    unsignedTx: string | Transaction,\n    password: string,\n    multiSign: boolean = false\n  ): Promise<SignedTransaction> {\n    let secureKey: SecureBuffer | null = null;\n    const startTime = Date.now();\n\n    try {\n      // Step 1: Decode transaction if it's a blob\n      let transaction: Transaction;\n      if (typeof unsignedTx === 'string') {\n        try {\n          transaction = decode(unsignedTx) as Transaction;\n        } catch (error) {\n          throw new SigningError(\n            'TRANSACTION_DECODE_ERROR',\n            `Failed to decode transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            { unsignedTx }\n          );\n        }\n      } else {\n        transaction = unsignedTx;\n      }\n\n      // Step 2: Validate transaction structure\n      this.validateTransaction(transaction);\n\n      // Step 3: Load wallet metadata\n      const walletEntry = await this.keystore.getWallet(walletId);\n\n      // Step 4: Load encrypted key from keystore (returns SecureBuffer)\n      try {\n        secureKey = await this.keystore.loadKey(walletId, password);\n      } catch (error) {\n        // Audit failed authentication\n        await this.auditLogger.log({\n          event: 'authentication_failed',\n          wallet_id: walletId,\n          wallet_address: walletEntry.address,\n          context: 'Authentication failed during transaction signing',\n        });\n\n        throw new SigningError(\n          'AUTHENTICATION_FAILED',\n          'Failed to decrypt wallet key - incorrect password or corrupted keystore',\n          { wallet_id: walletId }\n        );\n      }\n\n      // Step 5: Create ephemeral Wallet instance using SecureBuffer\n      let wallet: Wallet;\n      try {\n        // Convert buffer to seed string for xrpl.js Wallet\n        const seedString = secureKey.getBuffer().toString('utf-8');\n        wallet = Wallet.fromSeed(seedString);\n\n        // Verify address matches\n        if (wallet.address !== walletEntry.address) {\n          throw new Error('Wallet address mismatch - keystore corruption detected');\n        }\n      } catch (error) {\n        throw new SigningError(\n          'WALLET_CREATION_ERROR',\n          `Failed to create wallet from key: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          { wallet_id: walletId }\n        );\n      }\n\n      // Step 6: Sign the transaction\n      let signedResult: { tx_blob: string; hash: string };\n      try {\n        if (multiSign) {\n          // Multi-sign mode: SigningPubKey must be empty\n          signedResult = wallet.sign(transaction, true);\n        } else {\n          // Single-sign mode (normal)\n          signedResult = wallet.sign(transaction);\n        }\n      } catch (error) {\n        throw new SigningError(\n          'SIGNING_FAILED',\n          `Cryptographic signing failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          { wallet_id: walletId, transaction_type: transaction.TransactionType }\n        );\n      }\n\n      // Step 7: Audit successful signing\n      await this.auditLogger.log({\n        event: 'transaction_signed',\n        wallet_id: walletId,\n        wallet_address: walletEntry.address,\n        transaction_type: transaction.TransactionType as any,\n        tx_hash: signedResult.hash,\n        context: multiSign ? 'Multi-signature signing' : 'Single signature signing',\n      });\n\n      return {\n        tx_blob: signedResult.tx_blob,\n        hash: signedResult.hash,\n        signer_address: wallet.address,\n      };\n    } catch (error) {\n      // Audit signing failure (if not already logged)\n      if (error instanceof SigningError && error.code !== 'AUTHENTICATION_FAILED') {\n        await this.auditLogger.log({\n          event: 'transaction_failed',\n          wallet_id: walletId,\n          context: `Signing failed: ${error.code} - ${error.message}`,\n        });\n      }\n\n      throw error;\n    } finally {\n      // Step 8: CRITICAL - Zero key material\n      if (secureKey) {\n        secureKey.dispose();\n      }\n    }\n  }\n\n  /**\n   * Sign a transaction for multi-signature workflow.\n   *\n   * This is a convenience wrapper around sign() with multiSign=true.\n   *\n   * @param walletId - Internal wallet identifier\n   * @param unsignedTx - Unsigned transaction blob or object\n   * @param password - User password\n   * @returns Multi-signature compatible signed transaction\n   */\n  async signForMultiSig(\n    walletId: string,\n    unsignedTx: string | Transaction,\n    password: string\n  ): Promise<SignedTransaction> {\n    return this.sign(walletId, unsignedTx, password, true);\n  }\n\n  /**\n   * Decode and validate a transaction blob without signing.\n   *\n   * Useful for displaying transaction details before signing.\n   *\n   * @param txBlob - Transaction blob (hex encoded)\n   * @returns Decoded transaction object\n   * @throws SigningError TRANSACTION_DECODE_ERROR\n   */\n  decodeTransaction(txBlob: string): Transaction {\n    try {\n      return decode(txBlob) as Transaction;\n    } catch (error) {\n      throw new SigningError(\n        'TRANSACTION_DECODE_ERROR',\n        `Failed to decode transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { tx_blob: txBlob }\n      );\n    }\n  }\n\n  /**\n   * Encode a transaction object to blob format.\n   *\n   * @param transaction - Transaction object\n   * @returns Hex-encoded transaction blob\n   * @throws SigningError TRANSACTION_ENCODE_ERROR\n   */\n  encodeTransaction(transaction: Transaction): string {\n    try {\n      return encode(transaction);\n    } catch (error) {\n      throw new SigningError(\n        'TRANSACTION_ENCODE_ERROR',\n        `Failed to encode transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { transaction }\n      );\n    }\n  }\n\n  /**\n   * Validate transaction structure before signing.\n   *\n   * Checks:\n   * - Required fields present\n   * - Account address is valid\n   * - TransactionType is recognized\n   *\n   * @param transaction - Transaction to validate\n   * @throws SigningError INVALID_TRANSACTION\n   */\n  private validateTransaction(transaction: Transaction): void {\n    // Check required fields\n    if (!transaction.TransactionType) {\n      throw new SigningError(\n        'INVALID_TRANSACTION',\n        'Transaction missing required field: TransactionType'\n      );\n    }\n\n    if (!transaction.Account) {\n      throw new SigningError(\n        'INVALID_TRANSACTION',\n        'Transaction missing required field: Account'\n      );\n    }\n\n    // Validate Account address format (basic check)\n    if (!transaction.Account.startsWith('r') || transaction.Account.length < 25) {\n      throw new SigningError(\n        'INVALID_TRANSACTION',\n        `Invalid Account address format: ${transaction.Account}`\n      );\n    }\n\n    // Check for common XRPL transaction types\n    const validTypes = [\n      'Payment',\n      'OfferCreate',\n      'OfferCancel',\n      'TrustSet',\n      'AccountSet',\n      'SetRegularKey',\n      'SignerListSet',\n      'EscrowCreate',\n      'EscrowFinish',\n      'EscrowCancel',\n      'PaymentChannelCreate',\n      'PaymentChannelClaim',\n      'PaymentChannelFund',\n      'CheckCreate',\n      'CheckCash',\n      'CheckCancel',\n      'NFTokenMint',\n      'NFTokenBurn',\n      'NFTokenCreateOffer',\n      'NFTokenCancelOffer',\n      'NFTokenAcceptOffer',\n      'AMMCreate',\n      'AMMDeposit',\n      'AMMWithdraw',\n      'AMMVote',\n      'AMMBid',\n      'AMMDelete',\n      'DepositPreauth',\n      'AccountDelete',\n    ];\n\n    if (!validTypes.includes(transaction.TransactionType)) {\n      // Log warning but don't fail - new transaction types may be added\n      console.warn(`Unknown TransactionType: ${transaction.TransactionType}`);\n    }\n  }\n}\n","/**\n * Multi-Signature Orchestration\n *\n * Implements XRPL native multi-signature workflows for Tier 3 transactions.\n * Coordinates signature collection, quorum tracking, and transaction assembly.\n *\n * @module signing/multisig\n * @version 1.0.0\n */\n\nimport { randomUUID } from 'crypto';\nimport { Client, Wallet, multisign, type Transaction } from 'xrpl';\nimport type { AuditLogger } from '../audit/logger.js';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Signer configuration entry.\n */\nexport interface SignerConfig {\n  /**\n   * XRPL address of the signer.\n   */\n  address: string;\n\n  /**\n   * Weight assigned to this signer.\n   */\n  weight: number;\n\n  /**\n   * Role designation for UI/audit.\n   */\n  role: 'agent' | 'human_approver' | 'emergency';\n\n  /**\n   * Display name for notifications.\n   */\n  name?: string;\n\n  /**\n   * Contact info for notifications.\n   */\n  email?: string;\n\n  /**\n   * Optional: Hardware wallet locator.\n   */\n  walletLocator?: string;\n}\n\n/**\n * SignerList configuration for a wallet.\n */\nexport interface SignerListConfig {\n  /**\n   * Array of authorized signers.\n   */\n  signers: SignerConfig[];\n\n  /**\n   * Total weight required for valid signature.\n   */\n  quorum: number;\n\n  /**\n   * Timeout in seconds for pending requests.\n   * Default: 86400 (24 hours)\n   */\n  timeout_seconds?: number;\n}\n\n/**\n * Multi-signature request status.\n */\nexport type MultiSignStatus = 'pending' | 'approved' | 'rejected' | 'expired' | 'completed';\n\n/**\n * Signer state tracking.\n */\nexport interface SignerState {\n  /**\n   * Signer's XRPL address.\n   */\n  address: string;\n\n  /**\n   * Role designation.\n   */\n  role: 'agent' | 'human_approver' | 'emergency';\n\n  /**\n   * Assigned weight.\n   */\n  weight: number;\n\n  /**\n   * Whether this signer has signed.\n   */\n  signed: boolean;\n\n  /**\n   * Signature blob (if signed).\n   */\n  signature?: string;\n\n  /**\n   * When signature was received.\n   */\n  signed_at?: string; // ISO 8601\n}\n\n/**\n * Multi-signature request state.\n */\nexport interface MultiSignRequest {\n  /**\n   * Unique identifier (UUID v4).\n   */\n  id: string;\n\n  /**\n   * Internal wallet identifier.\n   */\n  wallet_id: string;\n\n  /**\n   * XRPL address of the account.\n   */\n  wallet_address: string;\n\n  /**\n   * Transaction details.\n   */\n  transaction: {\n    /**\n     * Transaction type (e.g., 'Payment', 'AccountSet').\n     */\n    type: string;\n\n    /**\n     * Amount in drops (if applicable).\n     */\n    amount_drops?: string;\n\n    /**\n     * Destination address (if applicable).\n     */\n    destination?: string;\n\n    /**\n     * Unsigned transaction blob (hex).\n     */\n    unsigned_blob: string;\n\n    /**\n     * Decoded transaction JSON (for display).\n     */\n    decoded: Transaction;\n  };\n\n  /**\n   * Signer tracking.\n   */\n  signers: SignerState[];\n\n  /**\n   * Quorum tracking.\n   */\n  quorum: {\n    /**\n     * Total weight required.\n     */\n    required: number;\n\n    /**\n     * Current collected weight.\n     */\n    collected: number;\n\n    /**\n     * Whether quorum is met.\n     */\n    met: boolean;\n  };\n\n  /**\n   * Request lifecycle status.\n   */\n  status: MultiSignStatus;\n\n  /**\n   * Timestamps.\n   */\n  created_at: string; // ISO 8601\n  expires_at: string; // ISO 8601\n  completed_at?: string; // ISO 8601\n\n  /**\n   * Result (if completed).\n   */\n  tx_hash?: string;\n\n  /**\n   * Rejection details (if rejected).\n   */\n  rejection?: {\n    rejecting_address: string;\n    reason: string;\n    rejected_at: string; // ISO 8601\n  };\n\n  /**\n   * Audit context.\n   */\n  context?: string;\n\n  /**\n   * Notification tracking.\n   */\n  notifications_sent: Array<{\n    recipient: string;\n    sent_at: string;\n    type: 'created' | 'signature_added' | 'completed' | 'rejected' | 'expired';\n  }>;\n}\n\n/**\n * Result of completing a multi-sign request.\n */\nexport interface MultiSignCompleteResult {\n  /**\n   * Request ID.\n   */\n  request_id: string;\n\n  /**\n   * Fully assembled multi-signed transaction blob (hex).\n   */\n  signed_tx: string;\n\n  /**\n   * Transaction hash from XRPL.\n   */\n  tx_hash: string;\n\n  /**\n   * Final quorum weight collected.\n   */\n  final_quorum: number;\n\n  /**\n   * Addresses that signed.\n   */\n  signers: string[];\n\n  /**\n   * Timestamp when submitted to XRPL.\n   */\n  submitted_at: string; // ISO 8601\n}\n\n/**\n * Multi-signature storage interface.\n */\nexport interface MultiSignStore {\n  /**\n   * Create a new multi-sign request.\n   */\n  create(request: MultiSignRequest): Promise<void>;\n\n  /**\n   * Get request by ID.\n   */\n  get(requestId: string): Promise<MultiSignRequest | null>;\n\n  /**\n   * Update existing request.\n   */\n  update(request: MultiSignRequest): Promise<void>;\n\n  /**\n   * List requests by wallet ID.\n   */\n  listByWallet(walletId: string, includeCompleted?: boolean): Promise<MultiSignRequest[]>;\n\n  /**\n   * List requests by status.\n   */\n  listByStatus(status: MultiSignStatus): Promise<MultiSignRequest[]>;\n\n  /**\n   * Find pending requests older than timestamp.\n   */\n  findPendingOlderThan(timestamp: Date): Promise<MultiSignRequest[]>;\n\n  /**\n   * Delete completed/expired requests older than retention period.\n   */\n  cleanup(retentionDays: number): Promise<number>;\n}\n\n/**\n * Notification service interface.\n */\nexport interface NotificationService {\n  /**\n   * Send notification about multi-sign event.\n   *\n   * @param notification - Notification details\n   * @returns Array of successful deliveries\n   */\n  notify(notification: unknown): Promise<unknown[]>;\n\n  /**\n   * Send reminder for pending signature.\n   *\n   * @param requestId - Multi-sign request ID\n   * @param recipientAddress - Signer's XRPL address\n   */\n  sendReminder(requestId: string, recipientAddress: string): Promise<void>;\n}\n\n/**\n * Multi-signature error class.\n */\nexport class MultiSignError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'MultiSignError';\n  }\n}\n\n// ============================================================================\n// MULTI-SIGN ORCHESTRATOR\n// ============================================================================\n\n/**\n * MultiSignOrchestrator - Coordinates multi-signature workflows.\n *\n * Responsibilities:\n * - Create pending multi-sign requests\n * - Collect signatures from multiple signers\n * - Track quorum progress\n * - Assemble final multi-signed transaction\n * - Handle timeouts and errors\n * - Notify approvers\n *\n * Security Features:\n * - Validates all signatures cryptographically\n * - Enforces quorum requirements\n * - Prevents duplicate signatures\n * - Handles request expiration\n * - Audits all operations\n *\n * @example\n * ```typescript\n * const orchestrator = new MultiSignOrchestrator(\n *   xrplClient,\n *   store,\n *   notifier,\n *   auditLogger\n * );\n *\n * // Initiate multi-sign request\n * const request = await orchestrator.initiate(\n *   'wallet_123',\n *   'rWallet...',\n *   unsignedTxBlob,\n *   signerConfig,\n *   'High-value payment'\n * );\n *\n * // Human approver adds signature\n * await orchestrator.addSignature(\n *   request.id,\n *   humanSignatureBlob,\n *   'rHuman...'\n * );\n *\n * // Complete and submit\n * const result = await orchestrator.complete(request.id, agentWallet);\n * ```\n */\nexport class MultiSignOrchestrator {\n  constructor(\n    private readonly xrplClient: Client,\n    private readonly store: MultiSignStore,\n    private readonly notificationService: NotificationService,\n    private readonly auditLogger: AuditLogger\n  ) {}\n\n  /**\n   * Initiate a new multi-signature request.\n   *\n   * Creates a pending request, notifies approvers, and returns\n   * the request ID for status tracking.\n   *\n   * @param walletId - Internal wallet identifier\n   * @param walletAddress - XRPL address of the account\n   * @param unsignedTx - Unsigned transaction blob (hex)\n   * @param signerConfig - SignerList configuration for this wallet\n   * @param context - Human-readable context for audit\n   * @returns Multi-signature request with pending status\n   *\n   * @throws MultiSignError WALLET_NOT_FOUND - Wallet doesn't exist\n   * @throws MultiSignError SIGNERLIST_NOT_CONFIGURED - Wallet has no SignerList\n   * @throws MultiSignError INVALID_TRANSACTION - Cannot decode transaction\n   */\n  async initiate(\n    walletId: string,\n    walletAddress: string,\n    unsignedTx: string,\n    signerConfig: SignerListConfig,\n    context?: string\n  ): Promise<MultiSignRequest> {\n    // Validate SignerList configuration\n    if (!signerConfig || signerConfig.signers.length === 0) {\n      throw new MultiSignError(\n        'SIGNERLIST_NOT_CONFIGURED',\n        'Wallet does not have multi-signature configured'\n      );\n    }\n\n    // Decode transaction\n    let decodedTx: Transaction;\n    try {\n      const { decode } = await import('xrpl');\n      decodedTx = decode(unsignedTx) as Transaction;\n    } catch (error) {\n      throw new MultiSignError(\n        'INVALID_TRANSACTION',\n        `Cannot decode transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { unsigned_tx: unsignedTx }\n      );\n    }\n\n    // Create request\n    const requestId = randomUUID();\n    const now = new Date();\n    const timeoutSeconds = signerConfig.timeout_seconds || 86400; // 24 hours default\n    const expiresAt = new Date(now.getTime() + timeoutSeconds * 1000);\n\n    const amountDrops = this.extractAmount(decodedTx);\n    const destination = this.extractDestination(decodedTx);\n\n    const request: MultiSignRequest = {\n      id: requestId,\n      wallet_id: walletId,\n      wallet_address: walletAddress,\n      transaction: {\n        type: decodedTx.TransactionType,\n        ...(amountDrops !== undefined && { amount_drops: amountDrops }),\n        ...(destination !== undefined && { destination }),\n        unsigned_blob: unsignedTx,\n        decoded: decodedTx,\n      },\n      signers: signerConfig.signers.map((s) => ({\n        address: s.address,\n        role: s.role,\n        weight: s.weight,\n        signed: false,\n      })),\n      quorum: {\n        required: signerConfig.quorum,\n        collected: 0,\n        met: false,\n      },\n      status: 'pending',\n      created_at: now.toISOString(),\n      expires_at: expiresAt.toISOString(),\n      ...(context && { context }),\n      notifications_sent: [],\n    };\n\n    // Store request\n    await this.store.create(request);\n\n    // Audit\n    await this.auditLogger.log({\n      event: 'approval_requested',\n      wallet_id: walletId,\n      wallet_address: walletAddress,\n      transaction_type: decodedTx.TransactionType as any,\n      context:\n        context || `Multi-sign requested: ${signerConfig.quorum} of ${signerConfig.signers.length} signatures`,\n    });\n\n    // Notify approvers (async, don't wait)\n    this.notifySigners(request, 'created').catch((err) =>\n      console.error('Failed to send notifications:', err)\n    );\n\n    return request;\n  }\n\n  /**\n   * Add a signature from a human approver.\n   *\n   * Validates the signature, stores it, and checks if quorum is met.\n   * Updates request status and notifies if ready for completion.\n   *\n   * @param requestId - Multi-sign request UUID\n   * @param signature - Signed transaction from approver\n   * @param signerAddress - Address of the signer (for validation)\n   * @returns Updated request with new signature and quorum status\n   *\n   * @throws MultiSignError REQUEST_NOT_FOUND - Request doesn't exist\n   * @throws MultiSignError REQUEST_EXPIRED - Request timeout exceeded\n   * @throws MultiSignError REQUEST_COMPLETED - Already finalized\n   * @throws MultiSignError INVALID_SIGNER - Address not in SignerList\n   * @throws MultiSignError DUPLICATE_SIGNATURE - Signer already signed\n   * @throws MultiSignError SIGNATURE_INVALID - Cryptographic verification failed\n   */\n  async addSignature(\n    requestId: string,\n    signature: string,\n    signerAddress: string\n  ): Promise<MultiSignRequest> {\n    // Load request\n    const request = await this.store.get(requestId);\n    if (!request) {\n      throw new MultiSignError('REQUEST_NOT_FOUND', `No request found with ID ${requestId}`);\n    }\n\n    // Check expiration\n    if (new Date(request.expires_at) < new Date()) {\n      throw new MultiSignError('REQUEST_EXPIRED', 'Multi-sign request has expired');\n    }\n\n    // Check status\n    if (request.status === 'completed') {\n      throw new MultiSignError('REQUEST_COMPLETED', 'Request already completed');\n    }\n    if (request.status === 'rejected') {\n      throw new MultiSignError('REQUEST_REJECTED', 'Request has been rejected');\n    }\n\n    // Find signer\n    const signer = request.signers.find((s) => s.address === signerAddress);\n    if (!signer) {\n      throw new MultiSignError(\n        'INVALID_SIGNER',\n        `Address ${signerAddress} is not in the SignerList`,\n        { signer_address: signerAddress, request_id: requestId }\n      );\n    }\n\n    // Check duplicate\n    if (signer.signed) {\n      throw new MultiSignError(\n        'DUPLICATE_SIGNATURE',\n        `Signer ${signerAddress} has already signed this request`\n      );\n    }\n\n    // TODO: Validate signature cryptographically\n    // For now, assume signature is valid (would require xrpl.js verify function)\n\n    // Update signer state\n    signer.signed = true;\n    signer.signature = signature;\n    signer.signed_at = new Date().toISOString();\n\n    // Recalculate quorum\n    const collectedWeight = request.signers\n      .filter((s) => s.signed)\n      .reduce((sum, s) => sum + s.weight, 0);\n\n    request.quorum.collected = collectedWeight;\n    request.quorum.met = collectedWeight >= request.quorum.required;\n\n    // Update status\n    if (request.quorum.met) {\n      request.status = 'approved';\n    }\n\n    // Store update\n    await this.store.update(request);\n\n    // Audit\n    await this.auditLogger.log({\n      event: 'approval_granted',\n      wallet_id: request.wallet_id,\n      wallet_address: request.wallet_address,\n      context: `Signature added by ${signerAddress} (${signer.role}). Quorum: ${collectedWeight}/${request.quorum.required}`,\n    });\n\n    // Notify if quorum met\n    if (request.quorum.met) {\n      this.notifySigners(request, 'signature_added').catch((err) =>\n        console.error('Failed to send notifications:', err)\n      );\n    }\n\n    return request;\n  }\n\n  /**\n   * Complete multi-signature and submit to XRPL.\n   *\n   * Verifies quorum is met, adds agent signature if needed,\n   * assembles the final multi-signed transaction, and submits.\n   *\n   * @param requestId - Multi-sign request UUID\n   * @param agentWallet - Agent's wallet (for final signature if needed)\n   * @returns Completed transaction with hash\n   *\n   * @throws MultiSignError REQUEST_NOT_FOUND - Request doesn't exist\n   * @throws MultiSignError REQUEST_EXPIRED - Request timeout exceeded\n   * @throws MultiSignError QUORUM_NOT_MET - Insufficient signatures\n   * @throws MultiSignError SUBMISSION_FAILED - XRPL submission error\n   */\n  async complete(requestId: string, agentWallet?: Wallet): Promise<MultiSignCompleteResult> {\n    // Load request\n    const request = await this.store.get(requestId);\n    if (!request) {\n      throw new MultiSignError('REQUEST_NOT_FOUND', `No request found with ID ${requestId}`);\n    }\n\n    // Check expiration\n    if (new Date(request.expires_at) < new Date()) {\n      throw new MultiSignError('REQUEST_EXPIRED', 'Multi-sign request has expired');\n    }\n\n    // Check if agent signature is needed\n    const agentSigner = request.signers.find((s) => s.role === 'agent');\n    if (agentSigner && !agentSigner.signed && agentWallet) {\n      // Add agent signature\n      const agentSig = agentWallet.sign(request.transaction.decoded, true);\n      agentSigner.signed = true;\n      agentSigner.signature = agentSig.tx_blob;\n      agentSigner.signed_at = new Date().toISOString();\n\n      // Recalculate quorum\n      const collectedWeight = request.signers\n        .filter((s) => s.signed)\n        .reduce((sum, s) => sum + s.weight, 0);\n      request.quorum.collected = collectedWeight;\n      request.quorum.met = collectedWeight >= request.quorum.required;\n    }\n\n    // Verify quorum\n    if (!request.quorum.met) {\n      throw new MultiSignError(\n        'QUORUM_NOT_MET',\n        `Collected weight ${request.quorum.collected} < required ${request.quorum.required}`\n      );\n    }\n\n    // Assemble multi-signed transaction\n    const signatures = request.signers.filter((s) => s.signed && s.signature).map((s) => s.signature!);\n\n    if (signatures.length === 0) {\n      throw new MultiSignError('NO_SIGNATURES', 'No signatures collected');\n    }\n\n    const multiSignedTx = multisign(signatures);\n\n    // Submit to XRPL\n    let txHash: string;\n    try {\n      const response = await this.xrplClient.submitAndWait(multiSignedTx, {\n        autofill: false,\n        failHard: true,\n      });\n\n      const meta = response.result.meta;\n      const result =\n        typeof meta === 'object' && meta !== null && 'TransactionResult' in meta\n          ? (meta.TransactionResult as string)\n          : 'UNKNOWN';\n      txHash = response.result.hash;\n\n      if (result !== 'tesSUCCESS') {\n        throw new Error(`Transaction failed with result: ${result}`);\n      }\n    } catch (error) {\n      throw new MultiSignError(\n        'SUBMISSION_FAILED',\n        `Failed to submit multi-signed transaction: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        { request_id: requestId }\n      );\n    }\n\n    // Update request\n    request.status = 'completed';\n    request.completed_at = new Date().toISOString();\n    request.tx_hash = txHash;\n    await this.store.update(request);\n\n    // Audit\n    await this.auditLogger.log({\n      event: 'transaction_submitted',\n      wallet_id: request.wallet_id,\n      wallet_address: request.wallet_address,\n      transaction_type: request.transaction.type as any,\n      tx_hash: txHash,\n      context: `Multi-signed transaction completed with ${signatures.length} signatures`,\n    });\n\n    return {\n      request_id: requestId,\n      signed_tx: multiSignedTx,\n      tx_hash: txHash,\n      final_quorum: request.quorum.collected,\n      signers: request.signers.filter((s) => s.signed).map((s) => s.address),\n      submitted_at: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Reject a pending multi-sign request.\n   *\n   * Human approver explicitly rejects the transaction.\n   * Discards all collected signatures and logs rejection.\n   *\n   * @param requestId - Multi-sign request UUID\n   * @param rejectingAddress - Address of the rejecting approver\n   * @param reason - Human-readable rejection reason\n   * @returns Updated request with rejected status\n   *\n   * @throws MultiSignError REQUEST_NOT_FOUND - Request doesn't exist\n   * @throws MultiSignError REQUEST_COMPLETED - Already finalized\n   * @throws MultiSignError UNAUTHORIZED_REJECTOR - Not an authorized signer\n   */\n  async reject(requestId: string, rejectingAddress: string, reason: string): Promise<MultiSignRequest> {\n    const request = await this.store.get(requestId);\n    if (!request) {\n      throw new MultiSignError('REQUEST_NOT_FOUND', `No request found with ID ${requestId}`);\n    }\n\n    if (request.status === 'completed') {\n      throw new MultiSignError('REQUEST_COMPLETED', 'Cannot reject completed request');\n    }\n\n    // Verify rejector is authorized\n    const rejector = request.signers.find((s) => s.address === rejectingAddress);\n    if (!rejector) {\n      throw new MultiSignError(\n        'UNAUTHORIZED_REJECTOR',\n        `Address ${rejectingAddress} is not an authorized signer`\n      );\n    }\n\n    // Update request\n    request.status = 'rejected';\n    request.rejection = {\n      rejecting_address: rejectingAddress,\n      reason,\n      rejected_at: new Date().toISOString(),\n    };\n    await this.store.update(request);\n\n    // Audit\n    await this.auditLogger.log({\n      event: 'approval_denied',\n      wallet_id: request.wallet_id,\n      wallet_address: request.wallet_address,\n      context: `Rejected by ${rejectingAddress}: ${reason}`,\n    });\n\n    return request;\n  }\n\n  /**\n   * Get current status of a multi-sign request.\n   *\n   * @param requestId - Multi-sign request UUID\n   * @returns Current request state with signatures and quorum\n   *\n   * @throws MultiSignError REQUEST_NOT_FOUND - Request doesn't exist\n   */\n  async getStatus(requestId: string): Promise<MultiSignRequest> {\n    const request = await this.store.get(requestId);\n    if (!request) {\n      throw new MultiSignError('REQUEST_NOT_FOUND', `No request found with ID ${requestId}`);\n    }\n    return request;\n  }\n\n  /**\n   * List all pending multi-sign requests for a wallet.\n   *\n   * @param walletId - Internal wallet identifier\n   * @param includeExpired - Include expired requests (default: false)\n   * @returns Array of pending requests sorted by creation time\n   */\n  async listPending(walletId: string, includeExpired: boolean = false): Promise<MultiSignRequest[]> {\n    return this.store.listByWallet(walletId, false);\n  }\n\n  /**\n   * Cancel an expired request.\n   *\n   * Automated cleanup of requests that exceeded timeout.\n   * Called by scheduled task, not directly by users.\n   *\n   * @param requestId - Multi-sign request UUID\n   * @returns Updated request with expired status\n   *\n   * @internal\n   */\n  async expire(requestId: string): Promise<MultiSignRequest> {\n    const request = await this.store.get(requestId);\n    if (!request) {\n      throw new MultiSignError('REQUEST_NOT_FOUND', `No request found with ID ${requestId}`);\n    }\n\n    request.status = 'expired';\n    await this.store.update(request);\n\n    await this.auditLogger.log({\n      event: 'approval_expired',\n      wallet_id: request.wallet_id,\n      wallet_address: request.wallet_address,\n      context: `Request expired with ${request.signers.filter((s) => s.signed).length}/${request.quorum.required} signatures`,\n    });\n\n    return request;\n  }\n\n  // ==========================================================================\n  // PRIVATE HELPERS\n  // ==========================================================================\n\n  private extractAmount(tx: Transaction): string | undefined {\n    if ('Amount' in tx && typeof tx.Amount === 'string') {\n      return tx.Amount;\n    }\n    return undefined;\n  }\n\n  private extractDestination(tx: Transaction): string | undefined {\n    if ('Destination' in tx && typeof tx.Destination === 'string') {\n      return tx.Destination;\n    }\n    return undefined;\n  }\n\n  private async notifySigners(request: MultiSignRequest, type: string): Promise<void> {\n    // Placeholder - would integrate with NotificationService\n    // For now, just log\n    console.log(`[MultiSign] Notification: ${type} for request ${request.id}`);\n  }\n}\n","/**\n * wallet_create Tool Implementation\n *\n * Creates a new XRPL wallet with policy controls and encrypted key storage.\n *\n * @module tools/wallet-create\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { WalletCreateInput, WalletCreateOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_create tool invocation.\n *\n * Creates a new agent wallet:\n * 1. Generate wallet keys via keystore\n * 2. Store policy configuration\n * 3. Audit wallet creation event\n * 4. Return wallet details (no private keys)\n *\n * @param context - Service instances\n * @param input - Validated wallet creation parameters\n * @returns Wallet creation result with address and public key\n */\nexport async function handleWalletCreate(\n  context: ServerContext,\n  input: WalletCreateInput\n): Promise<WalletCreateOutput> {\n  const { keystore, policyEngine, auditLogger } = context;\n\n  // Store policy configuration\n  await policyEngine.setPolicy(input.policy);\n\n  // Create wallet with policy reference\n  const walletEntry = await keystore.createWallet(\n    input.network,\n    {\n      policyId: input.policy.policy_id,\n      policyVersion: input.policy.policy_version,\n    },\n    {\n      name: input.wallet_name,\n      password: process.env.XRPL_WALLET_PASSWORD || '', // TEMP: env-based password\n      algorithm: 'ed25519', // Recommended for XRPL\n    }\n  );\n\n  // Generate master key backup (encrypted)\n  const backup = await keystore.exportBackup(\n    walletEntry.walletId,\n    process.env.XRPL_WALLET_PASSWORD || '',\n    'encrypted-json'\n  );\n\n  // Audit wallet creation\n  await auditLogger.log({\n    event: 'wallet_created',\n    seq: 0,\n    timestamp: new Date().toISOString(),\n    wallet_id: walletEntry.walletId,\n    wallet_address: walletEntry.address,\n    context: `Policy: ${input.policy.policy_id}`,\n    prev_hash: '',\n    hash: '',\n  });\n\n  return {\n    address: walletEntry.address,\n    regular_key_public: walletEntry.publicKey,\n    master_key_backup: JSON.stringify(backup),\n    policy_id: input.policy.policy_id,\n    wallet_id: walletEntry.walletId,\n    network: input.network,\n    created_at: walletEntry.createdAt,\n  };\n}\n","/**\n * wallet_sign Tool Implementation\n *\n * Signs transactions with policy enforcement (autonomous, delayed, co-sign, or prohibited).\n *\n * @module tools/wallet-sign\n * @version 1.0.0\n */\n\nimport { decode } from 'xrpl';\nimport type { ServerContext } from '../server.js';\nimport type { WalletSignInput, WalletSignOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_sign tool invocation.\n *\n * Process:\n * 1. Decode transaction to extract policy-relevant fields\n * 2. Evaluate transaction against wallet's policy\n * 3. Route based on tier:\n *    - Tier 1: Sign immediately (autonomous)\n *    - Tier 2: Queue for delayed approval\n *    - Tier 3: Request human co-signature\n *    - Tier 4: Reject with reason\n * 4. Audit all attempts (approved, pending, rejected)\n *\n * @param context - Service instances\n * @param input - Validated signing request\n * @returns Discriminated union: approved, pending, or rejected\n */\nexport async function handleWalletSign(\n  context: ServerContext,\n  input: WalletSignInput\n): Promise<WalletSignOutput> {\n  const { keystore, policyEngine, signingService, auditLogger } = context;\n\n  // Get wallet entry to find associated policy\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  // Decode transaction to extract fields\n  const decoded = decode(input.unsigned_tx);\n\n  // Evaluate policy\n  const policyResult = await policyEngine.evaluateTransaction(\n    wallet.policyId,\n    {\n      type: decoded.TransactionType,\n      destination: 'Destination' in decoded ? (decoded.Destination as string) : undefined,\n      amount_drops: 'Amount' in decoded && typeof decoded.Amount === 'string' ? decoded.Amount : undefined,\n    }\n  );\n\n  const timestamp = new Date().toISOString();\n\n  // Tier 4: Prohibited - reject immediately\n  if (policyResult.tier === 4) {\n    await auditLogger.log({\n      event: 'policy_violation',\n      seq: 0,\n      timestamp,\n      wallet_id: wallet.walletId,\n      wallet_address: wallet.address,\n      transaction_type: decoded.TransactionType,\n      tier: 4,\n      policy_decision: 'denied',\n      context: input.context,\n      prev_hash: '',\n      hash: '',\n    });\n\n    return {\n      status: 'rejected',\n      reason: policyResult.violations?.join('; ') || 'Transaction violates policy',\n      policy_tier: 4,\n    };\n  }\n\n  // Tier 2/3: Requires approval (not implemented yet - return pending)\n  if (policyResult.tier === 2 || policyResult.tier === 3) {\n    const approvalId = `approval_${Date.now()}_${wallet.walletId}`;\n\n    await auditLogger.log({\n      event: 'approval_requested',\n      seq: 0,\n      timestamp,\n      wallet_id: wallet.walletId,\n      wallet_address: wallet.address,\n      transaction_type: decoded.TransactionType,\n      tier: policyResult.tier,\n      policy_decision: 'pending',\n      context: input.context,\n      prev_hash: '',\n      hash: '',\n    });\n\n    return {\n      status: 'pending_approval',\n      approval_id: approvalId,\n      reason: policyResult.tier === 2 ? 'exceeds_autonomous_limit' : 'requires_cosign',\n      expires_at: new Date(Date.now() + 300000).toISOString(), // 5 minutes\n      policy_tier: policyResult.tier,\n    };\n  }\n\n  // Tier 1: Autonomous - sign immediately\n  const signed = await signingService.sign(\n    wallet.walletId,\n    input.unsigned_tx,\n    process.env.XRPL_WALLET_PASSWORD || ''\n  );\n\n  await auditLogger.log({\n    event: 'transaction_signed',\n    seq: 0,\n    timestamp,\n    wallet_id: wallet.walletId,\n    wallet_address: wallet.address,\n    transaction_type: decoded.TransactionType,\n    tx_hash: signed.hash,\n    tier: 1,\n    policy_decision: 'allowed',\n    context: input.context,\n    prev_hash: '',\n    hash: '',\n  });\n\n  return {\n    status: 'approved',\n    signed_tx: signed.tx_blob,\n    tx_hash: signed.hash,\n    policy_tier: 1,\n    limits_after: {\n      daily_remaining_drops: '0', // TEMP: Would come from policy engine\n      hourly_tx_remaining: 0,\n      daily_tx_remaining: 0,\n    },\n    signed_at: timestamp,\n  };\n}\n","/**\n * wallet_balance Tool Implementation\n *\n * Queries wallet balance and status from XRPL.\n *\n * @module tools/wallet-balance\n * @version 1.0.0\n */\n\nimport { dropsToXrp } from 'xrpl';\nimport type { ServerContext } from '../server.js';\nimport type { WalletBalanceInput, WalletBalanceOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_balance tool invocation.\n *\n * Process:\n * 1. Query XRPL for account info\n * 2. Calculate reserves (base + owner count)\n * 3. Return balance, reserves, and available funds\n *\n * @param context - Service instances\n * @param input - Validated balance query\n * @returns Wallet balance and status\n */\nexport async function handleWalletBalance(\n  context: ServerContext,\n  input: WalletBalanceInput\n): Promise<WalletBalanceOutput> {\n  const { keystore, xrplClient } = context;\n\n  // Get wallet entry to find network and policy\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  // Query XRPL for account info\n  const accountInfo = await xrplClient.getAccountInfo(wallet.network, input.wallet_address);\n\n  // Calculate reserves (TEMP: using hardcoded values - should query from XRPL)\n  const baseReserve = BigInt('1000000'); // 1 XRP\n  const ownerReserve = BigInt('200000'); // 0.2 XRP per object\n  const ownerCount = BigInt(accountInfo.OwnerCount || 0);\n  const totalReserve = baseReserve + ownerReserve * ownerCount;\n\n  const balance = BigInt(accountInfo.Balance);\n  const available = balance > totalReserve ? balance - totalReserve : BigInt(0);\n\n  return {\n    address: input.wallet_address,\n    balance_drops: balance.toString(),\n    balance_xrp: dropsToXrp(balance.toString()),\n    reserve_drops: totalReserve.toString(),\n    available_drops: available.toString(),\n    sequence: accountInfo.Sequence,\n    regular_key_set: !!accountInfo.RegularKey,\n    signer_list: null, // TEMP: Would parse SignerList from account objects\n    policy_id: wallet.policyId,\n    network: wallet.network,\n    queried_at: new Date().toISOString(),\n  };\n}\n","/**\n * wallet_policy_check Tool Implementation\n *\n * Dry-run policy evaluation without signing.\n *\n * @module tools/wallet-policy-check\n * @version 1.0.0\n */\n\nimport { decode } from 'xrpl';\nimport type { ServerContext } from '../server.js';\nimport type { WalletPolicyCheckInput, WalletPolicyCheckOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_policy_check tool invocation.\n *\n * Evaluates a transaction against policy without signing.\n * Useful for checking if a transaction will be approved before building it.\n *\n * @param context - Service instances\n * @param input - Validated policy check request\n * @returns Policy evaluation result\n */\nexport async function handleWalletPolicyCheck(\n  context: ServerContext,\n  input: WalletPolicyCheckInput\n): Promise<WalletPolicyCheckOutput> {\n  const { keystore, policyEngine } = context;\n\n  // Get wallet entry to find associated policy\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  // Decode transaction to extract fields\n  const decoded = decode(input.unsigned_tx);\n\n  // Evaluate policy\n  const policyResult = await policyEngine.evaluateTransaction(\n    wallet.policyId,\n    {\n      type: decoded.TransactionType,\n      destination: 'Destination' in decoded ? (decoded.Destination as string) : undefined,\n      amount_drops: 'Amount' in decoded && typeof decoded.Amount === 'string' ? decoded.Amount : undefined,\n    }\n  );\n\n  // Get current limit status (TEMP: mock data)\n  const limits = {\n    daily_volume_used_drops: '0',\n    daily_volume_limit_drops: '10000000000', // 10,000 XRP\n    hourly_tx_used: 0,\n    hourly_tx_limit: 10,\n    daily_tx_used: 0,\n    daily_tx_limit: 100,\n  };\n\n  return {\n    would_approve: policyResult.tier === 1,\n    tier: policyResult.tier,\n    warnings: policyResult.warnings || [],\n    violations: policyResult.violations || [],\n    limits,\n    transaction_details: {\n      type: decoded.TransactionType,\n      destination: 'Destination' in decoded ? (decoded.Destination as string) : undefined,\n      amount_drops: 'Amount' in decoded && typeof decoded.Amount === 'string' ? decoded.Amount : undefined,\n    },\n  };\n}\n","/**\n * wallet_rotate Tool Implementation\n *\n * Rotates the agent wallet signing key.\n *\n * @module tools/wallet-rotate\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { WalletRotateInput, WalletRotateOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_rotate tool invocation.\n *\n * Process:\n * 1. Generate new regular key pair\n * 2. Submit SetRegularKey transaction to XRPL\n * 3. Update keystore with new key\n * 4. Audit key rotation event\n *\n * SECURITY: This is a CRITICAL operation. Old key is disabled on-chain.\n *\n * @param context - Service instances\n * @param input - Validated rotation request\n * @returns Rotation result with new public key\n */\nexport async function handleWalletRotate(\n  context: ServerContext,\n  input: WalletRotateInput\n): Promise<WalletRotateOutput> {\n  const { keystore, auditLogger } = context;\n\n  // Get wallet entry\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  // TEMP: This is a placeholder implementation\n  // Full implementation would:\n  // 1. Generate new key pair via keystore\n  // 2. Build SetRegularKey transaction\n  // 3. Sign with current key\n  // 4. Submit to XRPL\n  // 5. Update keystore after validation\n\n  const timestamp = new Date().toISOString();\n\n  // Audit key rotation\n  await auditLogger.log({\n    event: 'key_rotated',\n    seq: 0,\n    timestamp,\n    wallet_id: wallet.walletId,\n    wallet_address: wallet.address,\n    context: input.reason || 'Manual rotation',\n    prev_hash: '',\n    hash: '',\n  });\n\n  // TEMP: Return mock response\n  return {\n    status: 'rotated',\n    new_regular_key_public: 'ED' + '0'.repeat(64), // Placeholder\n    old_key_disabled: true,\n    rotation_tx_hash: '0'.repeat(64), // Placeholder\n    rotated_at: timestamp,\n  };\n}\n","/**\n * wallet_list Tool Implementation\n *\n * Lists all managed wallets.\n *\n * @module tools/wallet-list\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { WalletListInput, WalletListOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_list tool invocation.\n *\n * Returns all wallets managed by this MCP instance,\n * optionally filtered by network.\n *\n * @param context - Service instances\n * @param input - Validated list request (optional network filter)\n * @returns List of wallet summaries\n */\nexport async function handleWalletList(\n  context: ServerContext,\n  input: WalletListInput\n): Promise<WalletListOutput> {\n  const { keystore } = context;\n\n  // Query keystore for wallets\n  const walletSummaries = await keystore.listWallets(input.network);\n\n  // Map to output format\n  const wallets = walletSummaries.map((w) => ({\n    wallet_id: w.walletId,\n    address: w.address,\n    name: w.name,\n    network: w.network,\n    policy_id: w.policyId,\n    created_at: w.createdAt,\n  }));\n\n  return {\n    wallets,\n    total: wallets.length,\n  };\n}\n","/**\n * wallet_history Tool Implementation\n *\n * Retrieves transaction history from XRPL.\n *\n * @module tools/wallet-history\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { WalletHistoryInput, WalletHistoryOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_history tool invocation.\n *\n * Queries XRPL for transaction history and returns\n * formatted entries with policy tier information.\n *\n * @param context - Service instances\n * @param input - Validated history request\n * @returns Transaction history entries\n */\nexport async function handleWalletHistory(\n  context: ServerContext,\n  input: WalletHistoryInput\n): Promise<WalletHistoryOutput> {\n  const { keystore, xrplClient } = context;\n\n  // Get wallet entry to find network\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  // Query XRPL for transaction history\n  const txHistory = await xrplClient.getTransactionHistory(\n    wallet.network,\n    input.wallet_address,\n    {\n      limit: input.limit || 20,\n      marker: input.marker,\n    }\n  );\n\n  // Map to output format\n  const transactions = txHistory.transactions.map((tx) => ({\n    hash: tx.hash,\n    type: tx.tx.TransactionType,\n    amount_drops: 'Amount' in tx.tx && typeof tx.tx.Amount === 'string' ? tx.tx.Amount : undefined,\n    destination: 'Destination' in tx.tx ? (tx.tx.Destination as string) : undefined,\n    timestamp: new Date((tx.close_time_iso || '')).toISOString(),\n    policy_tier: 1 as const, // TEMP: Would come from audit log\n    context: undefined, // TEMP: Would come from audit log\n    ledger_index: tx.ledger_index || 0,\n    success: tx.meta?.TransactionResult === 'tesSUCCESS',\n  }));\n\n  return {\n    address: input.wallet_address,\n    transactions,\n    marker: txHistory.marker,\n    has_more: !!txHistory.marker,\n  };\n}\n","/**\n * wallet_fund Tool Implementation\n *\n * Funds wallet from testnet/devnet faucet.\n *\n * @module tools/wallet-fund\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { WalletFundInput, WalletFundOutput } from '../schemas/index.js';\n\n/**\n * Handle wallet_fund tool invocation.\n *\n * Requests test XRP from faucet for testnet/devnet wallets.\n * Only available on non-mainnet networks.\n *\n * @param context - Service instances\n * @param input - Validated fund request\n * @returns Funding result\n */\nexport async function handleWalletFund(\n  context: ServerContext,\n  input: WalletFundInput\n): Promise<WalletFundOutput> {\n  const { xrplClient, auditLogger } = context;\n\n  // Ensure not on mainnet\n  if (input.network === 'mainnet') {\n    throw new Error('Faucet not available on mainnet');\n  }\n\n  try {\n    // Request funding from faucet\n    const fundResult = await xrplClient.fundWallet(input.network, input.wallet_address);\n\n    // Audit funding event\n    await auditLogger.log({\n      event: 'wallet_created', // Using existing event type\n      seq: 0,\n      timestamp: new Date().toISOString(),\n      wallet_address: input.wallet_address,\n      context: `Funded from ${input.network} faucet`,\n      prev_hash: '',\n      hash: '',\n    });\n\n    return {\n      status: 'funded',\n      amount_drops: fundResult.amount,\n      tx_hash: fundResult.hash,\n      new_balance_drops: fundResult.balance,\n    };\n  } catch (error) {\n    return {\n      status: 'failed',\n      error: error instanceof Error ? error.message : 'Unknown faucet error',\n    };\n  }\n}\n","/**\n * policy_set Tool Implementation\n *\n * Updates wallet policy configuration.\n *\n * @module tools/policy-set\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { PolicySetInput, PolicySetOutput } from '../schemas/index.js';\n\n/**\n * Handle policy_set tool invocation.\n *\n * Updates policy for an existing wallet.\n * SECURITY: This is a CRITICAL operation requiring human approval.\n *\n * @param context - Service instances\n * @param input - Validated policy update request\n * @returns Policy update result\n */\nexport async function handlePolicySet(\n  context: ServerContext,\n  input: PolicySetInput\n): Promise<PolicySetOutput> {\n  const { keystore, policyEngine, auditLogger } = context;\n\n  // Get wallet entry\n  const wallets = await keystore.listWallets();\n  const wallet = wallets.find((w) => w.address === input.wallet_address);\n\n  if (!wallet) {\n    throw new Error(`Wallet not found: ${input.wallet_address}`);\n  }\n\n  const previousPolicyId = wallet.policyId;\n\n  // TEMP: Policy changes always require approval in production\n  // For now, we'll apply directly but log as requiring approval\n  await policyEngine.setPolicy(input.policy);\n\n  // Update wallet metadata with new policy reference\n  await keystore.updateMetadata(wallet.walletId, {\n    customData: {\n      policyId: input.policy.policy_id,\n      policyVersion: input.policy.policy_version,\n    },\n  });\n\n  const timestamp = new Date().toISOString();\n\n  // Audit policy change\n  await auditLogger.log({\n    event: 'policy_updated',\n    seq: 0,\n    timestamp,\n    wallet_id: wallet.walletId,\n    wallet_address: wallet.address,\n    context: input.reason,\n    prev_hash: '',\n    hash: '',\n  });\n\n  return {\n    status: 'pending_approval', // TEMP: Would be 'applied' after approval\n    previous_policy_id: previousPolicyId,\n    new_policy_id: input.policy.policy_id,\n    approval_id: `policy_approval_${Date.now()}`,\n  };\n}\n","/**\n * tx_submit Tool Implementation\n *\n * Submits signed transaction to XRPL.\n *\n * @module tools/tx-submit\n * @version 1.0.0\n */\n\nimport type { ServerContext } from '../server.js';\nimport type { TxSubmitInput, TxSubmitOutput } from '../schemas/index.js';\n\n/**\n * Handle tx_submit tool invocation.\n *\n * Submits a signed transaction blob to the XRPL network\n * and optionally waits for validation.\n *\n * @param context - Service instances\n * @param input - Validated submission request\n * @returns Submission result\n */\nexport async function handleTxSubmit(\n  context: ServerContext,\n  input: TxSubmitInput\n): Promise<TxSubmitOutput> {\n  const { xrplClient, auditLogger } = context;\n\n  const submittedAt = new Date().toISOString();\n\n  // Submit transaction to XRPL\n  const result = await xrplClient.submitTransaction(\n    input.network,\n    input.signed_tx,\n    input.wait_for_validation ?? true\n  );\n\n  // Audit submission\n  await auditLogger.log({\n    event: 'transaction_submitted',\n    seq: 0,\n    timestamp: submittedAt,\n    tx_hash: result.hash,\n    policy_decision: result.validated ? 'allowed' : 'pending',\n    prev_hash: '',\n    hash: '',\n  });\n\n  return {\n    tx_hash: result.hash,\n    result: {\n      result_code: result.resultCode,\n      result_message: result.resultMessage,\n      success: result.resultCode === 'tesSUCCESS',\n    },\n    ledger_index: result.ledgerIndex,\n    submitted_at: submittedAt,\n    validated_at: result.validated ? new Date().toISOString() : undefined,\n  };\n}\n","/**\n * tx_decode Tool Implementation\n *\n * Decodes transaction blob for inspection.\n *\n * @module tools/tx-decode\n * @version 1.0.0\n */\n\nimport { decode, hashes } from 'xrpl';\nimport type { ServerContext } from '../server.js';\nimport type { TxDecodeInput, TxDecodeOutput } from '../schemas/index.js';\n\n/**\n * Handle tx_decode tool invocation.\n *\n * Decodes a hex-encoded transaction blob into readable JSON.\n * Works with both signed and unsigned transactions.\n *\n * @param context - Service instances\n * @param input - Validated decode request\n * @returns Decoded transaction fields\n */\nexport async function handleTxDecode(\n  _context: ServerContext,\n  input: TxDecodeInput\n): Promise<TxDecodeOutput> {\n  // Decode transaction blob\n  const decoded = decode(input.tx_blob);\n\n  // Check if transaction is signed (has TxnSignature or Signers)\n  const isSigned = 'TxnSignature' in decoded || 'Signers' in decoded;\n\n  // Extract signing public key if signed\n  const signingPublicKey = 'SigningPubKey' in decoded && typeof decoded.SigningPubKey === 'string'\n    ? decoded.SigningPubKey\n    : undefined;\n\n  // Calculate hash if signed\n  let hash: string | undefined;\n  if (isSigned) {\n    try {\n      hash = hashes.hashSignedTx(input.tx_blob);\n    } catch {\n      // Hash calculation failed - might be malformed\n      hash = undefined;\n    }\n  }\n\n  return {\n    transaction: decoded as any, // Type assertion - decoded tx matches schema\n    hash,\n    is_signed: isSigned,\n    signing_public_key: signingPublicKey,\n  };\n}\n","/**\n * MCP Server Implementation\n *\n * Main MCP server setup using @modelcontextprotocol/sdk.\n * Registers all wallet operation tools and wires up service dependencies.\n *\n * @module server\n * @version 1.0.0\n */\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  type CallToolRequest,\n  type Tool,\n} from '@modelcontextprotocol/sdk/types.js';\n\n// Import all tool implementations\nimport { handleWalletCreate } from './tools/wallet-create.js';\nimport { handleWalletSign } from './tools/wallet-sign.js';\nimport { handleWalletBalance } from './tools/wallet-balance.js';\nimport { handleWalletPolicyCheck } from './tools/wallet-policy-check.js';\nimport { handleWalletRotate } from './tools/wallet-rotate.js';\nimport { handleWalletList } from './tools/wallet-list.js';\nimport { handleWalletHistory } from './tools/wallet-history.js';\nimport { handleWalletFund } from './tools/wallet-fund.js';\nimport { handlePolicySet } from './tools/policy-set.js';\nimport { handleTxSubmit } from './tools/tx-submit.js';\nimport { handleTxDecode } from './tools/tx-decode.js';\n\n// Import service dependencies\nimport type { KeystoreProvider } from './keystore/interface.js';\nimport type { PolicyEngine } from './policy/engine.js';\nimport type { SigningService } from './signing/service.js';\nimport type { AuditLogger } from './audit/logger.js';\nimport type { XRPLClientWrapper } from './xrpl/client.js';\n\n// Import zod for type inference\nimport { z } from 'zod';\n\n// Import schemas for validation\nimport { InputSchemas, ErrorResponseSchema, type ErrorResponse } from './schemas/index.js';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Server context holding all service instances.\n */\nexport interface ServerContext {\n  keystore: KeystoreProvider;\n  policyEngine: PolicyEngine;\n  signingService: SigningService;\n  auditLogger: AuditLogger;\n  xrplClient: XRPLClientWrapper;\n}\n\n/**\n * Server configuration options.\n */\nexport interface ServerConfig {\n  /** Server name (for MCP identification) */\n  name?: string;\n  /** Server version */\n  version?: string;\n}\n\n// ============================================================================\n// TOOL DEFINITIONS\n// ============================================================================\n\n/**\n * Tool metadata for MCP registration.\n * Defines all available tools with their schemas and descriptions.\n */\nconst TOOLS: Tool[] = [\n  {\n    name: 'wallet_create',\n    description: 'Create a new XRPL wallet with policy controls. Generates keys locally with encrypted storage.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        network: { type: 'string', enum: ['mainnet', 'testnet', 'devnet'] },\n        policy: { type: 'object' },\n        wallet_name: { type: 'string' },\n        funding_source: { type: 'string' },\n        initial_funding_drops: { type: 'string' },\n      },\n      required: ['network', 'policy'],\n    },\n  },\n  {\n    name: 'wallet_sign',\n    description: 'Sign a transaction with policy enforcement. Returns signed blob, pending approval, or rejection.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        unsigned_tx: { type: 'string' },\n        context: { type: 'string' },\n      },\n      required: ['wallet_address', 'unsigned_tx'],\n    },\n  },\n  {\n    name: 'wallet_balance',\n    description: 'Query wallet balance, reserves, and status. Returns current state from XRPL.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n      },\n      required: ['wallet_address'],\n    },\n  },\n  {\n    name: 'wallet_policy_check',\n    description: 'Dry-run policy evaluation without signing. Check if a transaction would be approved.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        unsigned_tx: { type: 'string' },\n      },\n      required: ['wallet_address', 'unsigned_tx'],\n    },\n  },\n  {\n    name: 'wallet_rotate',\n    description: 'Rotate the agent wallet signing key. Disables old key and generates new one.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        reason: { type: 'string' },\n      },\n      required: ['wallet_address'],\n    },\n  },\n  {\n    name: 'wallet_list',\n    description: 'List all managed wallets, optionally filtered by network.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        network: { type: 'string', enum: ['mainnet', 'testnet', 'devnet'] },\n      },\n    },\n  },\n  {\n    name: 'wallet_history',\n    description: 'Retrieve transaction history for audit and analysis.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        limit: { type: 'number', minimum: 1, maximum: 100 },\n        marker: { type: 'string' },\n      },\n      required: ['wallet_address'],\n    },\n  },\n  {\n    name: 'wallet_fund',\n    description: 'Fund wallet from testnet/devnet faucet. Only available on test networks.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        network: { type: 'string', enum: ['testnet', 'devnet'] },\n      },\n      required: ['wallet_address', 'network'],\n    },\n  },\n  {\n    name: 'policy_set',\n    description: 'Update wallet policy (requires approval). Changes security constraints.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        wallet_address: { type: 'string' },\n        policy: { type: 'object' },\n        reason: { type: 'string' },\n      },\n      required: ['wallet_address', 'policy', 'reason'],\n    },\n  },\n  {\n    name: 'tx_submit',\n    description: 'Submit signed transaction to XRPL network.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        signed_tx: { type: 'string' },\n        network: { type: 'string', enum: ['mainnet', 'testnet', 'devnet'] },\n        wait_for_validation: { type: 'boolean' },\n      },\n      required: ['signed_tx', 'network'],\n    },\n  },\n  {\n    name: 'tx_decode',\n    description: 'Decode transaction blob for inspection. Works with signed or unsigned transactions.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        tx_blob: { type: 'string' },\n      },\n      required: ['tx_blob'],\n    },\n  },\n];\n\n// ============================================================================\n// ERROR HANDLING\n// ============================================================================\n\n/**\n * Convert an error to MCP error response format.\n */\nfunction formatError(error: unknown): ErrorResponse {\n  const timestamp = new Date().toISOString();\n\n  // If already an ErrorResponse, return it\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    'code' in error &&\n    'message' in error &&\n    'timestamp' in error\n  ) {\n    return error as ErrorResponse;\n  }\n\n  // Handle Error instances\n  if (error instanceof Error) {\n    return {\n      code: 'INTERNAL_ERROR',\n      message: error.message,\n      details: { stack: error.stack },\n      timestamp,\n    };\n  }\n\n  // Handle unknown error types\n  return {\n    code: 'INTERNAL_ERROR',\n    message: 'An unknown error occurred',\n    details: { error: String(error) },\n    timestamp,\n  };\n}\n\n// ============================================================================\n// SERVER IMPLEMENTATION\n// ============================================================================\n\n/**\n * Create and initialize the MCP server.\n *\n * @param context - Service instances (keystore, policy, signing, audit, xrpl)\n * @param config - Server configuration options\n * @returns Configured MCP server instance\n */\nexport function createServer(context: ServerContext, config?: ServerConfig): Server {\n  const server = new Server(\n    {\n      name: config?.name ?? 'xrpl-agent-wallet-mcp',\n      version: config?.version ?? '0.1.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // Register tools list handler\n  server.setRequestHandler(ListToolsRequestSchema, async () => ({\n    tools: TOOLS,\n  }));\n\n  // Register tool call handler\n  server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest) => {\n    const { name, arguments: args } = request.params;\n\n    try {\n      // Validate tool exists\n      const toolDef = TOOLS.find((t) => t.name === name);\n      if (!toolDef) {\n        throw new Error(`Unknown tool: ${name}`);\n      }\n\n      // Get input schema for validation\n      const inputSchema = InputSchemas[name as keyof typeof InputSchemas];\n      if (!inputSchema) {\n        throw new Error(`No schema found for tool: ${name}`);\n      }\n\n      // Validate input against Zod schema\n      const validatedInput = inputSchema.parse(args);\n\n      // Route to appropriate handler with proper type assertions\n      let result: unknown;\n      switch (name) {\n        case 'wallet_create':\n          result = await handleWalletCreate(context, validatedInput as z.infer<typeof InputSchemas.wallet_create>);\n          break;\n        case 'wallet_sign':\n          result = await handleWalletSign(context, validatedInput as z.infer<typeof InputSchemas.wallet_sign>);\n          break;\n        case 'wallet_balance':\n          result = await handleWalletBalance(context, validatedInput as z.infer<typeof InputSchemas.wallet_balance>);\n          break;\n        case 'wallet_policy_check':\n          result = await handleWalletPolicyCheck(context, validatedInput as z.infer<typeof InputSchemas.wallet_policy_check>);\n          break;\n        case 'wallet_rotate':\n          result = await handleWalletRotate(context, validatedInput as z.infer<typeof InputSchemas.wallet_rotate>);\n          break;\n        case 'wallet_list':\n          result = await handleWalletList(context, validatedInput as z.infer<typeof InputSchemas.wallet_list>);\n          break;\n        case 'wallet_history':\n          result = await handleWalletHistory(context, validatedInput as z.infer<typeof InputSchemas.wallet_history>);\n          break;\n        case 'wallet_fund':\n          result = await handleWalletFund(context, validatedInput as z.infer<typeof InputSchemas.wallet_fund>);\n          break;\n        case 'policy_set':\n          result = await handlePolicySet(context, validatedInput as z.infer<typeof InputSchemas.policy_set>);\n          break;\n        case 'tx_submit':\n          result = await handleTxSubmit(context, validatedInput as z.infer<typeof InputSchemas.tx_submit>);\n          break;\n        case 'tx_decode':\n          result = await handleTxDecode(context, validatedInput as z.infer<typeof InputSchemas.tx_decode>);\n          break;\n        default:\n          throw new Error(`Handler not implemented for tool: ${name}`);\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    } catch (error) {\n      const errorResponse = formatError(error);\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: JSON.stringify(errorResponse, null, 2),\n          },\n        ],\n        isError: true,\n      };\n    }\n  });\n\n  return server;\n}\n\n/**\n * Run the MCP server with stdio transport.\n *\n * @param context - Service instances\n * @param config - Server configuration\n */\nexport async function runServer(context: ServerContext, config?: ServerConfig): Promise<void> {\n  const server = createServer(context, config);\n  const transport = new StdioServerTransport();\n\n  await server.connect(transport);\n\n  // Log server start to audit\n  await context.auditLogger.log({\n    event: 'server_started',\n  });\n\n  console.error('XRPL Agent Wallet MCP Server running on stdio');\n}\n"]}